---
title: 多线程与高并发4
tags:
  - JavaSE
  - 多线程
  - 面试题
  - AQS
  - JUC
categories: 多线程
abbrlink: 3067f77e
date: 2020-09-17 12:05:10
---

摘要：面试题，Condition，AQS

<!-- more -->

> [淘宝面试题1](https://github.com/ogugugugugua/Java-Notes/tree/2237b94422e32529f6a1825a3023975be95c560c/code/multiThread/src/com/interviewExercises/ex1)：实现一个容器，提供两个方法add size，写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束

**解法详解：**

- T01并不能用，因为线程1更改的内容对于线程2来说并不可见。
- T02和T03本质上属于在T01基础上增加了volatile关键字，虽然可行但是很奇怪：volatile修饰的是指向内存地址的指针，而这个指针是不会随着内存中值的修改而变化的，所以并不能合理地解释为什么线程1修改的值能够及时让线程2感知到。暂时放下不表。
- T04也不能用。因为notify不释放锁，所以线程1即使唤醒了线程2，但是并没有释放掉锁，线程2只能等着。
- T05是真正可用的版本，需要背下来，这是最基础原始的写法。线程1在容器到达指定size的时候通知线程2的同时需要把自己停掉，等线程2执行完之后再唤醒线程1。
- T06与T05在思想上高度雷同，但是使用了两个CountDownLatch这个工具，使得原来的wait方法变成了latch.wait，原来的notify方法变成了latch.countDown方法。
- T07是最简洁的版本，同样与T05在思想上高度雷同，使用了LockSupport工具，使用park方法代替wait来停住自己，使用unpark方法代替notify来唤醒另外一个线程。



---

> [淘宝面试题2](https://github.com/ogugugugugua/Java-Notes/tree/2237b94422e32529f6a1825a3023975be95c560c/code/multiThread/src/com/interviewExercises/ex2)：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程和10个消费者线程的阻塞调用。

- 这是经典的题目，需要直接**背**好解题。
- 需要注意的是需要使用while来判断当前size和最大/最小限制的关系。
- T01是比较高效的版本，由于引入了Condition这个工具，只会唤醒指定线程队列里面的等待队列。

---

## LockSupport

unpark可以在park前调用，以失效即将到来的park。可以看出比wait和notify更灵活。

---

## Condition

本质就是等待队列！

---

## AQS	

AbstractQueuedSynchronizer 是很**重要**的类，需要仔细阅读源码

模板方法 钩子函数; template method, callback function