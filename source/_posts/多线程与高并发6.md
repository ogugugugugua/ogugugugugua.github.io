---
title: 多线程与高并发6
tags:
  - JavaSE
  - 多线程
  - Java容器
  - 阻塞队列
categories: 多线程
abbrlink: de699652
date: 2020-09-21 12:05:10
---
摘要：容器，阻塞队列，源码解析

<!-- more -->

## 容器

在物理结构上只有两种：连续存储（数组）和非连续存储（链表）

按照编排方式可以按下图的方式进行分离：**【背好】**

![](https://user-images.githubusercontent.com/17522733/97811254-9583de80-1c79-11eb-87be-708336293afd.png)

这个BlockingQueue阻塞队列主要服务于高并发的任务。

Deque是双端队列。

Vector和HashTable的很多操作都加了synchronized，所以在一定程度上性能一般般。

---

## HashMap && HashTable && ConcurrentHashMap 

HashMap没有加synchronized，所以它不是线程安全的。

通过Collections.synchronizedMap(new HashMap<>());可以获得线程安全的HashMap。在底层实现上依旧是加了synchronized。

目前来说HashTable和Vector基本不用。

现在有一个**读效率**更高的ConcurrentHashMap。

**注意**：上述的这些Map并不是绝对的替代关系，因为CAS和synchronized没有绝对的优劣之分，要根据实际情况下并发量的大小和并发代码的执行时间进行具体的判断。

---

## ConcurrentLinkedQueue

注意：即使使用了线程安全的容器比如vector，依然有可能会出现问题，比如我们调用了synchronized的size方法判断大小之后，再调用synchronized的remove方法去除元素，但是中间可能会有别的线程对容器进行干预，也就是说两个原子操作之间并不能保证原子性。

解决办法：使用ConcurrentLinkedQueue（对应remove的是poll方法）。以后对于单个元素的集合，尽量考虑Queue集合而不是List集合，因为其对高并发具有更好的支持。

查看源码可以发现ConcurrentLinkedQueue的底层原子性是通过CAS来实现的，所以其效率很高。

---

## TreeMap && ConcurrentSkipListMap

TreeMap使用红黑树实现，内部已排序，在查找的时候效率高。

ConcurrentSkipListMap支持高并发而且排序。通过跳表来实现。（代替了不存在的ConcurrentTreeMap）

跳表的结构是这样的：

![](https://www.xstnet.com/uploads/images/2019-09/b7ec1e2fa4791f9a16e5bd661fc50040.png)

最底层基础的还是一个链表结构，然后在其上层逐步进行抽象，只拿下层的若干个关键节点，这样有利于减少查询次数。

---

## CopyOnWriteList / CopyOnWriteSet 写时复制

应用场景：写得少，读得多。（因为这个结构在读的时候不加锁，写的时候进行一波复制）

这个东西的源码非常容易理解：

```java
//添加一个元素：Appends the specified element to the end of this list.
public boolean add(E e) {		
    final ReentrantLock lock = this.lock;
    lock.lock();				//锁上
    try {
        Object[] elements = getArray();	
        int len = elements.length;	//获取原数组长度
        Object[] newElements = Arrays.copyOf(elements, len + 1);	//复制一个新数组，并指定长度加一
        newElements[len] = e;		//设定最新添加的元素在末位
        setArray(newElements);		//更改引用
        return true;
    } finally {
        lock.unlock();				//释放锁
    }
}
```

```java
//删除一个元素Removes the element at the specified position in this list. Shifts any subsequent elements to the left
public E remove(int index) {	
    final ReentrantLock lock = this.lock;
    lock.lock();						//锁上
    try {
        Object[] elements = getArray();
        int len = elements.length;			//获取原数组长度
        E oldValue = get(elements, index);	//获取被删除的元素
        int numMoved = len - index - 1;		//计算index后方需要移动的元素个数
        if (numMoved == 0)					//index后方需要移动的元素个数为0，即删除了最后一个元素
            setArray(Arrays.copyOf(elements, len - 1));	//直接把整个数组复制到新的数组里并忽略最后一位即可
        else {
            Object[] newElements = new Object[len - 1];	//先new一个新的数组
            System.arraycopy(elements, 0, newElements, 0, index);	//复制前半部分
            System.arraycopy(elements, index + 1, newElements, index, numMoved);	//复制后半部分
            setArray(newElements);			//指向新的引用								
        }
        return oldValue;					//返回被删除的元素
    } finally {
        lock.unlock();						//释放锁
    }
}
```

---

## BlockingQueue 阻塞队列

重点在“阻塞”上。有以下几种：

- DelayBlockingQueue可以实现在时间上的排序。
- ArrayBlockingQueue有界的。
- LinkedBlockingQueue无界的。
- SynchronousQueue一般用于线程间传递任务。
- TransferQueue也同于线程间传递任务，可以传多个。

---

## LinkedBlockingQueue

关于Queue这个类的方法，一般常用offer来增加，用peek来查看顶端，poll来查看并删除顶端。

对于BlockingQueue这个接口而言，会有以下的方法：

1. 添加元素：

- add：有位置则增加，如果满了就会报错
- offer：有位置则增加，如果满了就会返回false
- put：有位置则增加，如果满了就会阻塞到有位置再增加

2. 删除元素：

- remove：有对应元素则删除并返回true，否则返回false
- poll(long timeout, TimeUnit unit)：返回并删除队列的头节点，等待时间超过unit之后就会有中断异常
- take：返回并删除队列的头结点，如果队列为空则阻塞直到有值可以返回

显然这种BlockingQueue就是天生对线程安全的生产着消费者模型

比如我们可以看LinkedBlockingQueue的put方法源码：

```java
//类成员
/** Lock held by take, poll, etc */
private final ReentrantLock takeLock = new ReentrantLock();

/** Wait queue for waiting takes */
private final Condition notEmpty = takeLock.newCondition();

/** Lock held by put, offer, etc */
private final ReentrantLock putLock = new ReentrantLock();

/** Wait queue for waiting puts */
private final Condition notFull = putLock.newCondition();



/**
 * Inserts the specified element at the tail of this queue, waiting if
 * necessary for space to become available.
 *
 * @throws InterruptedException {@inheritDoc}
 * @throws NullPointerException {@inheritDoc}
 */
public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    // Note: convention in all put/take/etc is to preset local var
    // holding count negative to indicate failure unless set.
    int c = -1;
    Node<E> node = new Node<E>(e);	//即将放进去的Node节点
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;//当前元素个数
    putLock.lockInterruptibly();	//锁上
    try {
        while (count.get() == capacity) {
            notFull.await();		//满了就等待
        }
        enqueue(node);				//放进去
        c = count.getAndIncrement(); //当前元素个数是之前个数+1
        if (c + 1 < capacity)
            notFull.signal();		//加完之后还没满，可以让其他等待着的线程继续添加元素
    } finally {
        putLock.unlock();			//解锁
    }
    if (c == 0)
        signalNotEmpty();			//加完之后就刚好不空了，唤醒那些等待着take的线程来取元素
}
```

而ArrayBlockingQueue可以指定容量capacity，满了的时候如果使用put方法就会阻塞，同理满了的时候使用add就会抛出异常。

---

### **总结一下**：

- Queue和List这两个集合的区别主要在于对于多线程的支持，提供了很多友好的API，比如offer，peek，poll。
- Queue的子类BlockingQueue又添加了一些与阻塞相关的API，比如take，put。

---

## 几个特殊一些的BlockingQueue

**DelayQueue**可以按照在里面等待的时间进行排序。本质上使用的是PriorityQueue，应用场景：按照时间进行任务调度。

**SynchrnousQueue**的使用场景类似于Exchanger。需要有一个线程在阻塞着等take拿数据时候，才可以另一个线程往里面put放数据，否则无法放进去。内部无法存储元素，当要添加元素的时候，需要阻塞。

**LinkedTransferQueue**可以算是 `LinkedBolckingQueue` 和 `SynchronousQueue` 和合体。`LinkedTransferQueue`是 `SynchronousQueue` 和 `LinkedBlockingQueue` 的合体，性能比 `LinkedBlockingQueue` 更高（没有锁操作），比 `SynchronousQueue`能存储更多的元素。

当 `put` 时，如果有等待的线程，就直接将元素 “交给” 等待者， 否则直接进入队列。	

`put`和 `transfer` 方法的区别是，put 是立即返回的， transfer 是阻塞等待消费者拿到数据才返回。`transfer`方法和 `SynchronousQueue`的 put 方法类似。