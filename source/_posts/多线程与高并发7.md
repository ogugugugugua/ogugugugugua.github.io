---
title: 多线程与高并发7
tags:
  - JavaSE
  - 多线程
  - 线程池
categories: 多线程
abbrlink: a96ea6c4
date: 2020-09-23 12:05:10
---

摘要：线程池图解，FutureTask，ThreadPoolExecutor

<!-- more -->

## 线程池

> 上层有Executor接口，中间有ExecutorService接口，下层有ThreadPoolExecutor类。
>

我们使用Callable接口可以定义类似于Runnable功能的任务，然后交给线程去执行。区别在于Callable具有返回值，而且其使用场景一般与线程池相关。

由于Callable提交给线程池之后的执行是相对主线程异步的，所以我们可以把Callable将来执行产生的结果存储在Future这个类中。

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    Callable<String> callable = new Callable<String>() {
        @Override
        public String call() throws Exception {
            System.out.println("enter callable");
            Thread.sleep(1000);
            return "test";
        }
    };

    ExecutorService service = Executors.newCachedThreadPool();
    Future<String> future = service.submit(callable);//异步的
    System.out.println(future.get());//阻塞的，因此会等1秒才得到输出
    service.shutdown();
}
```

---

## FutureTask

相当于一个任务，此任务完成之后的结果页存储在其之中。其实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable和Future两个接口。很灵活：

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    FutureTask<String> task = new FutureTask<>(()->{
        System.out.println("enter future task");
        Thread.sleep(2000);
        return "test";
    });
    new Thread(task).start();
    System.out.println(task.get());
}
```

---

## CompletableFuture

可以近似理解成多个Future的管理类。一个很有意思的应用是：在多个网站上使用多个线程同步拉取数据，当这些线程把任务都执行完之后，继续主线程，代码在[仓库](https://github.com/ogugugugugua/Java-Notes/blob/c54b05757bf18a7db3d95af93808e8b249ba0f81/code/multiThread/src/com/threadPool/testCompletableFuture.java)。

在这里我们能很明显地看到CompletableFuture对于管理多个Future是很有效的，典型API如`allof`或者`anyof`用来指定当`全部`或者`其中之一`的任务完成时才做接下来的工作。

---

## 线程池类型

1. ThreadPoolExecutor
2. ForkJoinPool：
   1. 用于分解汇总的任务
   2. 用很少的线程可以执行很多的任务（子任务），而ThreadPoolExecutor做不到先执行子任务
   3. CPU密集型

![两种线程池](https://user-images.githubusercontent.com/17522733/98050291-a6775000-1e31-11eb-9dcc-f977979dfd66.png)

**阿里手册中要求线程池要自定义。**

**线程池维护着两个集合：线程的集合 && 任务的集合。**

---

## ThreadPoolExecutor

与上层接口的关系：

![image-20201102210928195](https://user-images.githubusercontent.com/17522733/97914181-c6364780-1d4f-11eb-86b5-c25fbdf42045.png)

其自定义初始化需要有7个参数【背】：

```java
public ThreadPoolExecutor(int corePoolSize,						//核心线程数(不归还给操作系统)
                          int maximumPoolSize,					//最大线程数(扩容的最大值)
                          long keepAliveTime,					//空闲线程存活时间数值
                          TimeUnit unit,						//存活时间单位
                          BlockingQueue<Runnable> workQueue,	 //任务队列(类型是阻塞队列)
                          ThreadFactory threadFactory,			 //线程工厂 (产生什么类型的线程等)
                          RejectedExecutionHandler handler)		 //拒绝策略
```

对于第5个参数，能够在某种程度上决定这个线程池的一些特点，比如：假设我们使用SynchrnousQueue，就会来一个任务则马上被处理，因为其容量为0。

对于第6个参数，我们可以自定义线程工厂。【阿里：创建线程或线程池时请指定有意义的线程名称，方便出错时回溯】。在`Executors.java`里面有一个`static class DefaultThreadFactory implements ThreadFactory`默认线程工厂，其中的核心函数`newThread`就会指定线程的名字。

> 阿里手册中，线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式能够更加明确线程池的运行规则，避免资源耗尽的风险。是**因为**：FixedThreadPool和SingleThreadPool允许的**请求队列长度**为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。CachedThreadPool允许的**创建线程数量**为Integer.MAX_VALUE，可能会创建大量的线程，从而也导致OOM。

啊！

对于第7个参数拒绝策略，默认有4种，在真实场景中往往会自定义。