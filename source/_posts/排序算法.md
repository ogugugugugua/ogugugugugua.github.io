---
title: 排序算法
categories: 算法
tags:
  - 排序算法
  - 算法
abbrlink: '735e5788'
date: 2020-02-01 15:40:15
---


# 快速排序

## 示意图

![quickSort](https://user-images.githubusercontent.com/17522733/98710150-90aee100-2383-11eb-854f-bb4791b5e55e.gif)

<!-- more -->

## 基本思想：**挖坑填数 + 分治法**

1. 从序列中取出一个数作为基准数
2. 分区过程：将比这个数大的数全部放到它的右边，小于或等于它的数全部放到它的左边
3. 递归地对左右子序列尽心步骤2，直到各区间只有一个数

---



## 举例

我们这里有初始数组如下

| i=0  |  1   |  2   |  3   |  4   |  5   |  6   | j=7  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| (49) |  38  |  65  |  97  |  76  |  13  |  27  |  49  |

对于这个算法，我们需要两个变量`i`和`j`分别代表数组的两端，这两个变量将会分别往中间靠拢。

约定取当前区间的第一个元素为`index`作为参考，即`index = arr[i] = arr[0] = 49`。

这时`i=0`的地方就已经挖了一个坑。我们从数组的右端开始往左遍历`j`，找出比`index`小的数`arr[j]`，填到`arr[i]`即 `arr[0]`的位置；

显然当`j=6`时满足`arr[6]<index`，所以按照上一行的解释`arr[0] = arr[i] = arr[j] = arr[6] = 27`，并且`i++`，数组变成：

|  0   | i=1  |  2   |  3   |  4   |  5   | j=6  |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  27  |  38  |  65  |  97  |  76  |  13  | (27) |  49  |

这时`j=6`的地方就挖了一个坑。我们从数组的左端开始往右遍历`i`，找出比`index`大的数`arr[i]`，填到`arr[j]`即`arr[6]`的位置；

显然当`i=2`的时候满足`arr[2]>index`，所以按照上一行的解释`arr[6] = arr[j] = arr[i] = arr[2] = 65`，并且`j--`，数组变成：

|  0   |  1   | i=2  |  3   |  4   | j=5  |  6   |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  27  |  38  | (65) |  97  |  76  |  13  |  65  |  49  |

这是`i=2`的地方就被挖出一个坑。

再重复上面的步骤，**先从后往前找，再从前往后找**。

从`j`开始往前找，当`j=5`时，符合条件，将`arr[5]`挖出一个坑，`arr[i] = arr[2]`的坑被填上，并且`i++`，数组变成：。

|  0   |  1   |  2   | i=3  |  4   | j=5  |  6   |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  27  |  38  |  13  |  97  |  76  | (13) |  65  |  49  |

从`i`开始往后找，当`i=3`时，符合条件，将`arr[3]`挖出一个坑，`arr[j] = arr[5]`的坑被填上，并且`j--`，数组变成：。

|  0   |  1   |  2   | i=3  | j=4  |  5   |  6   |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  27  |  38  |  13  | (97) |  76  |  97  |  65  |  49  |

从`j`开始往前找，此时`i==3,j==4`，由于要保持`i<j`这个条件，所以无法再继续找到合适的元素。

这时只需要把`index`填回去`arr[i]`这个坑即可：

|  0   |  1   |  2   |    3     |  4   |  5   |  6   |  7   |
| :--: | :--: | :--: | :------: | :--: | :--: | :--: | :--: |
|  27  |  38  |  13  | index=49 |  76  |  97  |  65  |  49  |

通过上面这一轮可以看出，`arr[3]`前面的数字都小于它，`arr[3]`后面的数字都大于它。

只需要对`arr[0...2]`和`arr[4....7]`这两个子区间重复上述步骤即可。

---



## 对挖坑填数进行总结

1．i = L; j = R; 将基准数挖出形成第一个坑 a[i]。

2．j-- 由后向前找比它小的数，找到后挖出此数填前一个坑 a[i] 中。

3．i++ 由前向后找比它大的数，找到后也挖出此数填到前一个坑 a[j] 中。

4．再重复执行 2，3 二步，直到 i==j，将基准数填入 a[i] 中。



## 实现代码：

```java
import java.util.Arrays;

public class MySolution {
    public static void sort(int[] a, int low, int high){
        int i = low, j = high;
        if (low > high) {
            return;
        }
        int temp = a[i];        //挖坑，取当前区间的第一个数为基准
        while (i < j) {
            while (i < j && a[j] >= temp) {
                j--;            //j-- 由后向前找比它小的数
            }
            if (i<j){
                a[i] = a[j];        //找到后挖出此数填前一个坑 a[i] 中
                i++;
            }
            while (i < j && a[i] < temp) {
                i++;            //i++ 由前向后找比它大的数
            }
            if (i<j){
                a[j] = a[i];        //找到后也挖出此数填到前一个坑 a[j] 中
                j--;
            }
        }
        a[i] = temp;
        sort(a, low, i-1);
        sort(a, i+1, high);
    }

    public static void quickSort(int[] a){
        sort(a, 0, a.length - 1);
    }

    public static void main(String[] args) {
        int a[] = { 49, 38, 65, 97, 76, 13, 27, 49 };
        quickSort(a);
        System.out.println(Arrays.toString(a));
    }
}
```

