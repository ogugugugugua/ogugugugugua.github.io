---
title: 多线程与高并发3
tags:
  - JavaSE
  - 多线程
  - JUC
categories: 多线程
abbrlink: ae0362dd
date: 2020-09-15 12:05:10
---

摘要：LongAdder ，ReentrantLock，CyclicBarrier，读写锁ReadWriteLock，semaphore

<!-- more -->

## LongAdder 

分段锁。

---

## ReentrantLock

它的使用可以替代synchronized：在原来使用synchronized(this)的地方换成reentrantLock.lock()，然后记得最后要reentrantLock.unlock()。同时要注意把lock()写在try里面，unlock()写在finally里面。以避免出现异常而无法正常释放锁。

ReentrantLock有一些比synchronized要强大的地方，比如：

- 可以尝试锁，自行决定等待锁时间：

  ```java
  Lock lock = new ReentrantLock();
  try {
      lock.tryLock(6, TimeUnit.MILLISECONDS);
  } catch (InterruptedException e) {
      e.printStackTrace();
  }finally {
      lock.unlock();
  }
  ```

- 可以被打断的加锁

  ```java
  Lock lock = new ReentrantLock();
  try {
      lock.lockInterruptibly();
  } catch (InterruptedException e) {
      e.printStackTrace();
  }finally {
      lock.unlock();
  }
  ```

- 可以实现公平锁：即先到先得，最后来的锁不能马上抢到对象，而是要进入等待队列中排队

  ```java
  Lock lock1 = new ReentrantLock(true);
  ```

---

## CyclicBarrier

一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。

### 应用场景

在某种需求中，比如一个大型的任务，常常需要分配好多子任务去执行，只有当所有子任务都执行完成时候，才能执行主任务，这时候，就可以选择CyclicBarrier了。具体地，一个请求过来之后需要先进行数据库操作+文件操作+计算操作，这三者可以使用三个线程来同步执行，当这三个任务都执行完成后，执行一个渲染页面任务，此时可以在前三者的任务代码中调用CyclicBarrier的await()方法，然后把最后一个任务内容写在CyclicBarrier的Runnable里面。

> CyclicBarrier好比一扇门，默认情况下关闭状态，堵住了线程执行的道路，直到所有线程都就位，门才打开，让所有线程一起通过。

```java
CyclicBarrier barrier = new CyclicBarrier(3, new Runnable() {
    @Override
    public void run() {
        System.out.println("run application");		//主任务
    }
});

Runnable runnable = new Runnable() {				//子任务
    @Override
    public void run() {
        try {
            System.out.println(Thread.currentThread().getName());
            barrier.await();						//子任务中await一次CyclicBarrier
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
};

for (int i = 0; i < 3; i++) {
    new Thread(runnable,"Thread"+i).start();
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

---

## 读写锁ReadWriteLock

对于一些读操作频繁而写操作不频繁的业务来说有巨大的性能提升。由ReentrantReadWriteLock类提供。

```java
public static void main(String[] args) {
    ReentrantLock lock = new ReentrantLock();
    ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    Lock readLock = readWriteLock.readLock();
    Lock writeLock = readWriteLock.writeLock();
    for (int i = 0; i < 20; i++) {
        new Thread(()->read(readLock)).start();		//这里传入readLock就会迅速执行完毕，若传入lock则会有漫长的等待
    }
    for (int i = 0; i < 2; i++) {
        new  Thread(()->write(writeLock)).start();
    }
}

public static void read(Lock lock) {
    lock.lock();
    try {
        System.out.println("read");
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}

public static void write(Lock lock) {
    lock.lock();
    try {
        System.out.println("write");
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }finally {
        lock.unlock();
    }
}
```

---

## semaphore

可以用来【限流】。

无论有多少个线程活跃着，能运行的（获取到锁）只有permits限定的这么多个。每次acquire就会使得permits减一，每次release就会加一。

可以形象地理解成车道和收费站的关系。

