---
title: 多线程与高并发2
tags:
  - JavaSE
  - 多线程
  - volatile
  - synchronized
  - CAS
categories: 多线程
abbrlink: d904524b
date: 2020-09-13 12:05:10
---

摘要：volatile，单例模式，synchronized优化，CAS

<!-- more -->

## volatile作用：

- 保证线程可见性 
- 禁止指令重排序

单例模式，懒汉生成法，要保证线程安全【双重检查】：

```java
public class test{
    private static volatile test INSTANCE; //要加volatile，原因解释在下方
    private test(){}
    public getInstance(){
        if(INSTANCE==null){	//判断的时候先不加锁
            synchronized (test.class){
                if(INSTANCE==null){	//上一次判断后，要加锁，在new之前，看看在此期间是否有被别的线程抢占了锁并已经new出来了对象
                    INSTANCE=new test();
                }
            }
        }
        return INSTANCE;	//返回单例
    }
    public void someFunctions(){
        System.out.println("some functions.");
    }
    public static void main(String[] args){
        for(int i = 0; i<100; i++){
            new Thread(()->{
                System.out.println(test.getInstance().hashcode());
            }).start();
        }
    }
}
```

## 问题：双重检查写法的单例模式是否要加volatile？

答案：**要的**。

INSTANCE=new test();这一句话在JVM中有三个步骤：1. 申请内存（带有默认值）。2. 设置成员的值。3. 让引用指向内存的地址。

在不加volatile的情况下，上述的第2第3个步骤可能会进行指令重排，也就是：申请内存->引用指向内存地址->设置成员的值。

在超高并发的场景下，线程A在new的过程中申请了带有默认值的内存，并把引用指向了该地址，还没来得及修改成员的值。此时线程B查看INSTANCE不为空，直接返回该单例并使用。在这种情况下，线程B拿到的成员的值是不对的，因为线程A还没有正确地初始化它。

加了volatile之后指令重排序不被允许，那么线程A在new的过程中就可以保证成员的值被正确初始化后才赋值给引用，就不会出现上述的问题了。

**结论：双重检查写法的单例模式要加volatile**。

---

## synchronized优化

锁的细化，只加在需要锁的那部分代码。

如果synchronized对某个对象进行锁，那么建议那个对象添加修饰词final，以避免出现对象引用变化的情况。

不要用String类型来作为锁的对象。

---

## CAS compare and swap/set 

无锁优化 或者叫 **乐观锁**。

AtomicInteger可以实现。

**ABA问题**解决：加版本号。修改一次版本号加一，检查的时候包括值本身和版本号。AtomicStampedReference类可以做到。

其实对于基本数据类型并没有问题，对于引用类型需要留意。