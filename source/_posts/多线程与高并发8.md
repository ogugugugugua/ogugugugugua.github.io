---
title: 多线程与高并发8
tags:
  - JavaSE
  - 多线程
  - 线程池
  - 源码
categories: 多线程
abbrlink: 39d1bb55
date: 2020-09-25 12:05:10
---

摘要：Executors，ThreadPoolExecutors源码，ForkPoolJoin

<!-- more -->

## Executors

可以看成是线程池的工厂。可以返回各种线程池。

何时用Cached何时用Fixed？

> 对于任务的到来具有峰谷值的情况下推荐用Cached，而对于任务的到来比较平缓的情况推荐使用Fixed。

---

## 单线程的线程池

单线程的线程池`Executors.newSingleThreadExecutor()`可以保证进去的任务被顺序执行。而且其内部帮忙维护了任务队列，就蛮好的。

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,								//核心线程数是1，最大线程数也是1
                                0L, TimeUnit.MILLISECONDS,				//非核心线程存活时间为0，因为没有非核心线程
                                new LinkedBlockingQueue<Runnable>()));	//最大长度为Integer.MAX_VALUE
}
```

## 缓存线程池

`Executors.newCachedThreadPool()`的特点是：在线程数量少于Integer.MAX_VALUE的情况下，来一个任务就会起一个新的线程来执行。存货时间是60秒。实现的原理是任务队列类型为SynchronousQueue，其容量为0，如果没有take掉的话就会处于阻塞状态。

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,				//核心线程数是0，最大线程数是Integer.MAX_VALUE
                                  60L, TimeUnit.SECONDS,			//非核心线程存活时间为60秒
                                  new SynchronousQueue<Runnable>());	//任务队列类型为SynchronousQueue，来一个执行一个
}
```

对于定时任务线程池，可以使用`Executors.newScheduledThreadPool()`，也推荐使用quartz或者cron这两种工具。

---

## 并行VS并发：

> 并发指任务提交，并行指任务执行。

---

## ThreadPoolExecutor源码解析

从上面的源码可以看出来，其底层的线程池创建还是调用了ThreadPoolExecutor函数，现在来看看它的源码：

常用变量的解析

```java
//1. ctl 可以看做一个int类型的数字，高3位代表线程池状态，低29位代表worker数量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
//2. 这个数是32-3=29
private static final int COUNT_BITS = Integer.SIZE - 3;
//3. 线程池允许的最大线程数，即2^29-1
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

// runState is stored in the high-order bits
//4. 线程池有5种状态，按大小排序为RUNNING < SHUTDOWN < STOP < TIDYING< TERMINATED
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;
```

构造方法并没有太多新意，主要是检查参数是否合法以及是否为空，然后进行赋值

```java
if (corePoolSize < 0 ||
    maximumPoolSize <= 0 ||
    maximumPoolSize < corePoolSize ||
    keepAliveTime < 0)
    throw new IllegalArgumentException();
if (workQueue == null || threadFactory == null || handler == null)
    throw new NullPointerException();
```

### 执行提交的task的过程

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * Proceed in 3 steps:
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task.  The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn't, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread.  If it fails, we know we are shut down or saturated
     * and so reject the task.
     */
    int c = ctl.get();
    //worker数量比核心线程数小，直接创建worker执行任务
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();	//由于多线程的缘故，需要再次取值
    }
    //worker数量超过核心线程数，任务直接进入队列
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        //若线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject操作
        //这里做recheck的原因是任务进入队列前后，线程池的状态可能会发生改变
        if (! isRunning(recheck) && remove(command))
            reject(command);
        //若检查可用的核心线程数为0，则增加非核心线程
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    //如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务
    //
    else if (!addWorker(command, false))
        reject(command);
}
```

## **ThreadPoolExecutor的execute方法执行过程总结**：

1. 核心线程数不够：新增核心线程。
2. 核心线程数够了：加队列。
3. 核心线程够了 && 队列满了： 新增非核心线程。

流程图如下：

![ThreadPoolExecutor java public void execute(Runnable command) 源码流程图即对应代码 (1)](https://user-images.githubusercontent.com/17522733/98036969-2e059480-1e1b-11eb-98b2-1b2304c4bf2f.png)

---

addWorker可以理解为添加线程的函数：

​	count++； 真的增加一个worker并start；

---

worker本身是一个Runnable的子类。进来到线程池里的任务用worker来包装一下。因为里面有很多的状态需要记录，比如有一个成员变量thread用于记录当前任务所处的线程。

---

## ForkJoinPool

[ForkJoinPool](https://github.com/ogugugugugua/Java-Notes/blob/1056bd9cd0ecb1557599bf73977c333ad0d6c39e/code/multiThread/src/com/threadPool/testForkJoinPool.java)适合处理将大任务分解成小任务的情况。先分叉再汇总。

首先需要定义适合这种线程池处理的任务，底层一点的有ForkJoinTask，常用的它的子类有RecursiveAction（不带返回值）和RecursiveTask（带返回值）。

---

Executors.netWorkStealingPool() 是ForkJoin类型的线程池。

特点：每个线程有自己单独的队列！