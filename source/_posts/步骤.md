---
title: 网约车项目实现步骤
tags:
  - SpringCloud
  - 源码
  - Eureka
categories: 网约车
abbrlink: f28ceb4b
date: 2020-11-11 22:34:10
---

网约车项目搭建的详细步骤及相关原理和源码解读

<!-- more -->
# Eureka集群搭建

## 添加配置

新建工程，在`application.yml`文件中进行配置如下。在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，即`register-with-eureka: false`和 `fetch-registry: false`两行。

在这里我们构建了3个节点。注意`service-url.defaultZone`要写上所有的节点信息，不要遗漏，以避免注册信息无法同步的问题发生。这个配置选项代表” 默认服务注册中心地址“，是与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。

对于单节点的EurekaServer来说，它并没有将本机所存储的注册表信息同步到其他节点的需求。在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为。所以对于单节点EurekaServer来说设置`register-with-eureka`和`fetch-registry`都是false。

然而对于多节点的EurekaServer来说，它们之间需要进行注册表信息的同步操作，而EurekaServer并没有主从机之分，所以在这个角度看，它们之间需要相互注册为对方的EurekaClient并从对方那里拉取注册表信息。因此对于多节点的EurekaServer来说，应该设置`register-with-eureka`和`fetch-registry`都为true。

```yml
spring:
  application:
    name: eureka

eureka:
  client:
    register-with-eureka: false
    fetch-registry: false
    service-url:
      defaultZone: http://localhost:7900/eureka/,http://localhost:7901/eureka/,http://localhost:7902/eureka/   #这里记得全部要写好

--- #这里相当于另一个文件：

spring:
  profiles: 7900
server:
  port: 7900
eureka:
  instance:
    hostname: eureka-7900

--- #这里相当于另一个文件：

spring:
  profiles: 7901
server:
  port: 7901
eureka:
  instance:
    hostname: eureka-7901

--- #这里相当于另一个文件：

spring:
  profiles: 7902
server:
    port: 7902
eureka:
    instance:
      hostname: eureka-7902
---
```

在`Edit Configuration`里面配置好用到的3个`Active profiles`，然后分别启动这3个应用。

## Eureka的启动方式和原理

### 添加依赖

一方面，在`pom.xml`中我们引入了这个依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```

查找对应的dependencies可以看到里面启用了自动配置类

```factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration
```

然后我们可以在`EurekaServerAutoConfiguration`类中看到这样的注解：

```java
@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)
```

### 开启服务注册

另一方面，我们在主启动程序入口处添加了`@EnableEurekaServer`注解。

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
```

这个注解的核心作用是`@Import(EurekaServerMarkerConfiguration.class)`，导入的这个EurekaServerMarkerConfiguration配置类的内容是：

```java
@Configuration(proxyBeanMethods = false)
public class EurekaServerMarkerConfiguration {

	@Bean
	public Marker eurekaServerMarkerBean() {
		return new Marker();
	}

	class Marker {
	}
}
```

也就是说这里注入的Marker空类相当于一个**开关**，使能了`EurekaServerAutoConfiguration`的注入。

**总结：`pom.xml`引入了相关的Eureka server类(没有注入)，其注入是通过注解`@EnableEurekaServer`来控制的。**

---

# api-passenger

这里我们来实现一个服务提供方Service Provider；需要将自身服务注册到Eureka注册中心，从而使服务消费方能够找到。

## 添加依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

## 添加配置

新建工程，在`application.yml`文件中进行配置：

```yml
server:
  port: 8080
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7900/eureka
spring:
  application:
    name: api-passenger
```

在确保上述3个Eureka注册中心集群已启动的情况下，启动当前的api-passenger应用，即可以在http://localhost:7900 刷新看到有新的服务注册进来。

这个api-passenger是作为client服务提供商，注册到Eureka注册中心里。目测这里的defaultZone指定了注册中心的URL，而这几个注册中心之间会相互进行同步。

`@EnableDiscoveryClient`启用了服务发现的功能，只要 Eureka Client 启动了，就能被 Eureka Server 所感知。

## Eureka Server与Client交互的全流程

> 1. EurekaServer 提供服务发现的能力，各个微服务启动时，会向EurekaServer注册自己的信息（例如：ip、端口、微服务名称等），EurekaServer会存储这些信息；
> 2. EurekaClient是一个Java客户端，用于简化与EurekaServer的交互；
> 3. 微服务启动后，会定期性（默认30s）的向EurekaServer发送心跳以续约自己的“租期”；
> 4. 如果EurekaServer在一定时间内未接收某个微服务实例的心跳，EurekaServer将会注销该实例（默认90s）；
> 5. 默认情况下，EurekaServer同时也是EurekaClient。多个EurekaServer实例，互相之间通过复制的方式，来实现服务注册表中数据的同步；
> 6. EurekaClient也会缓存服务注册表中的信息。

## 相关优化选项
### Eureka是AP而不是CAP：

> A是高可用：因为有集群，所以高可用得以保证。
>
> P是分区容错性：因为EurekaServer是定时踢除服务的，所以即使在某一段时间内，clientA虽然可用但是因为网络故障无法续约，但是其注册信息依然存在于EurekaServer中，clientB还是可以拉取到注册表信息，来调用clientA的服务。

### 1. eureka.server.response-cache-update-interval-ms: 1000
- 服务更新间隔，该值默认是30秒，代表每隔多少秒就会更新一波可用的服务列表，越小则更新频率越高，能更及时地对服务的可用性进行更新。

### 2. eureka.server.enable-self-preservation

- 是否开启自我保护模式，默认为true。
- 默认情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例（默认90秒）。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。

- Eureka通过“自我保护模式”来解决这个问题——当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。

- 综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留），也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。

### 3. eureka.server.eviction-interval-timer-in-ms

- eureka server清理无效节点的时间间隔，默认60000毫秒，即60秒

### 4. eureka.server.use-read-only-response-cache: false
- 关闭从readOnly读注册表

### 5. eureka.instance.lease-renewal-interval-in-seconds  

- 设置续约间隔时间
- leaseRenewalIntervalInSeconds，表示eureka client发送心跳给server端的频率。**【写在instance客户端】**
- 如果在leaseExpirationDurationInSeconds后，server端没有收到client的心跳，则将摘除该instance。除此之外，如果该instance实现了HealthCheckCallback，并决定让自己unavailable的话，则该instance也不会接收到流量。【默认30秒】

### 6. eureka.client.registry-fetch-interval-seconds

- 表示eureka client间隔多久去拉取服务注册信息，默认为30秒，对于api-gateway，如果要迅速获取服务注册状态，可以缩小该值，比如5秒

### 7. eureka.instance.lease-expiration-duration-in-seconds

- leaseExpirationDurationInSeconds，表示eureka server至上一次收到client的心跳之后，等待下一次心跳的超时时间，在这个时间内若没收到下一次心跳，则将移除该instance。**【写在Server服务端】**
  - 默认为90秒
  - 如果该值太大，则很可能将流量转发过去的时候，该instance已经不存活了。
  - 如果该值设置太小了，则instance则很可能因为临时的网络抖动而被摘除掉。
  - 该值至少应该大于leaseRenewalIntervalInSeconds



---

## 源码分析

根据上面`Eureka的启动方式和原理`的分析，我们关注的源码是`EurekaServerAutoConfiguration`这个类：

`@Import`导入了`EurekaServerInitializerConfiguration`这个类，做了以下3件事：

1. 从peer拉取注册表
2. 启动定时踢除任务
3. 自我保护

### EurekaServerAutoConfiguration类源码解读

![EurekaServerAutoConfiguration调用过程及源码分析](https://user-images.githubusercontent.com/17522733/99147254-d1f30980-267f-11eb-8698-9b44a85dd5df.png)

[在processon中打开](https://www.processon.com/embed/5fa2cf640791291e95cd9822)

---

### Eureka会把自身节点上的服务注册信息同步到peer上，相关源码分析：

![Eureka同步注册信息到peer节点](https://user-images.githubusercontent.com/17522733/98934488-73445900-24e2-11eb-842a-c2095c83cf9c.png)

[在processon中打开](https://www.processon.com/embed/5fac57fce0b34d74f9d53c5d)

---

### 踢除服务：

> 默认情况下，如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障(比如网络故障或频繁的启动关闭客户端)，Eureka Server自动进入自我保护模式。不再剔除任何服务，当网络故障恢复后，该节点自动退出自我保护模式。
>
> 自我保护模式是一种对网络异常的安全保护措施。使用自我保护模式让Eureka集群更加的健壮、稳定。
>
> 禁用保护模式适合在开发/测试环境中使用，生产环境建议打开自我保护模式。
>
> 自我保护这个功能，保护的是CAP中的P，而不管C

- 自我保护关闭：踢除。
- 自我保护打开：
  - 最后一分钟续约数大于阈值：踢除
  - 最后一分钟续约数小于阈值：不踢除
- **【总结】**：联系上面优化部分中对于自我保护含义的描述，当且仅当**自我保护开启且续约数过少**时，才会把自己保护起来，才会**不踢除**。

![Eureka启动过程部分源码-01](https://user-images.githubusercontent.com/17522733/98933916-96bad400-24e1-11eb-9840-b43620e8619f.png)

[在processon中打开](https://www.processon.com/embed/5fa2d0dfe0b34d28c56d7fea)

---

### Eureka续约服务源码解析：

![Eureka续约服务](https://user-images.githubusercontent.com/17522733/98866836-d7790580-246d-11eb-85a7-3e28387c6138.png)
[在processOn中打开](https://www.processon.com/embed/5fac440a5653bb4cab728835)

---

## 估算Eureka服务器的承载量

**承载量 = 续约次数*实例数**

假设设置的`eureka.instance.lease-renewal-interval-in-seconds=30`

假设有20个服务，每个服务部署5个实例，即有100个Eureka client

每30秒一个服务实例注册一次，1分钟所有服务实例注册200次，

一天内所有服务实例注册`200*60*24`次，算出来EurekaServer一天会有28万的心跳访问量。

除此之外，每个client还需要拉取服务列表，默认频率也是30秒，

所以算上服务列表拉取的话，一天内啥都不做EurekaServer会有56万的访问量。

但是我们根据压测可以发现，EurekaServer的效率极高，一秒钟最少能有1000次的注册和拉取。==》承受几百个微服务来注册和拉取是完全没有问题的。

由于EurekaServer集群间的每个节点都需要相互同步数据，所以可以发现**EurekaServer的集群并没有扩大承受能力，只是实现了HA高可用**。

这里计算Eureka承载量的**意义**在于选择合适当前项目的服务器，要有匹配的CPU和内存等。

---

## 拉取注册表

