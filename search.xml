<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网约车项目实现步骤</title>
      <link href="archives/f28ceb4b.html"/>
      <url>archives/f28ceb4b.html</url>
      
        <content type="html"><![CDATA[<h2 id="Eureka集群搭建"><a href="#Eureka集群搭建" class="headerlink" title="Eureka集群搭建"></a>Eureka集群搭建</h2><p>新建工程，在<code>application.yml</code>文件中进行配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7900/eureka/,http://localhost:7901/eureka/,http://localhost:7902/eureka/</span>   <span class="comment">#这里记得全部要写好</span></span><br><span class="line"></span><br><span class="line"><span class="string">---</span> <span class="comment">#这里相当于另一个文件：</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="number">7900</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7900</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka-7900</span></span><br><span class="line"></span><br><span class="line"><span class="string">---</span> <span class="comment">#这里相当于另一个文件：</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="number">7901</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7901</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka-7901</span></span><br><span class="line"></span><br><span class="line"><span class="string">---</span> <span class="comment">#这里相当于另一个文件：</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="number">7902</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">7902</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">      <span class="attr">hostname:</span> <span class="string">eureka-7902</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>在<code>Edit Configuration</code>里面配置好用到的3个<code>Active profiles</code>，然后分别启动这3个应用。</p><h3 id="Eureka的启动方式和原理"><a href="#Eureka的启动方式和原理" class="headerlink" title="Eureka的启动方式和原理"></a>Eureka的启动方式和原理</h3><p>一方面，在<code>pom.xml</code>中我们引入了这个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>查找对应的dependencies可以看到里面启用了自动配置类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">  org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration</span><br></pre></td></tr></table></figure><p>然后我们可以在<code>EurekaServerAutoConfiguration</code>类中看到这样的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)</span></span><br></pre></td></tr></table></figure><p>另一方面，我们在主启动程序入口处添加了<code>@EnableEurekaServer</code>注解，这个注解的核心作用是<code>@Import(EurekaServerMarkerConfiguration.class)</code>，导入的这个EurekaServerMarkerConfiguration配置类的内容是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerMarkerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Marker <span class="title">eurekaServerMarkerBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Marker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Marker</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说这里注入的Marker空类相当于一个<strong>开关</strong>，使能了<code>EurekaServerAutoConfiguration</code>的注入。</p><p><strong>总结：<code>pom.xml</code>引入了相关的Eureka server类(没有注入)，其注入是通过注解<code>@EnableEurekaServer</code>来控制的。</strong></p><hr><h2 id="api-passenger"><a href="#api-passenger" class="headerlink" title="api-passenger"></a>api-passenger</h2><p>新建工程，在<code>application.yml</code>文件中进行配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7900/eureka</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-passenger</span></span><br></pre></td></tr></table></figure><p>在确保上述3个Eureka注册中心集群已启动的情况下，启动当前的api-passenger应用，即可以在<a href="http://localhost:7900/">http://localhost:7900</a> 刷新看到有新的服务注册进来。</p><p>这个api-passenger是作为client服务提供商，注册到Eureka注册中心里。目测这里的defaultZone指定了注册中心的URL，而这几个注册中心之间会相互进行同步。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li><p>服务更新间隔<code>server.response-cache-update-interval-ms: 1000</code>，该值默认是30秒，代表每隔多少秒就会更新一波可用的服务列表，越小则更新频率越高，能更及时地对服务的可用性进行更新。</p></li><li><p>自我保护和自我保护的阈值：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span></span><br></pre></td></tr></table></figure></li><li><p>踢除服务时间间隔：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure></li><li><p>关闭从readOnly读注册表：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><p>Eureka是AP而不是CAP。</p><p>我们关注的源码是<code>EurekaServerAutoConfiguration</code>这个类：</p><p><code>@Import</code>导入了<code>EurekaServerInitializerConfiguration</code>这个类，做了以下3件事：</p><ol><li>从peer拉取注册表</li><li>启动定时踢除任务</li><li>自我保护</li></ol><p><strong>关于是否踢除服务</strong>：</p><ul><li>自我保护关闭：踢除。</li><li>自我保护打开：<ul><li>最后一分钟续约数大于阈值：踢除</li><li>最后一分钟续约数小于阈值：不踢除</li></ul></li></ul><p>Eureka续约服务源码解析：</p><p><img src="http://assets.processon.com/chart_image/5fac440a5653bb4cab728838.png" alt="Eureka续约服务"></p><p><a href="https://www.processon.com/embed/5fac440a5653bb4cab728835">https://www.processon.com/embed/5fac440a5653bb4cab728835</a></p>]]></content>
      
      
      <categories>
          
          <category> 网约车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM笔记</title>
      <link href="archives/ea51d21f.html"/>
      <url>archives/ea51d21f.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存模型。"><a href="#Java内存模型。" class="headerlink" title="Java内存模型。"></a>Java内存模型。</h2><p>更准确说是“<strong>Java线程内存模型</strong>”。其与CPU缓存模型类似，是标准化的，屏蔽了底层不同计算机的区别。</p><a id="more"></a><p><img src="https://user-images.githubusercontent.com/17522733/93672081-6558f580-faa8-11ea-8eea-69497c849c2e.png" alt="未命名文件 (7)"></p><p>这里牵涉到一个可见性问题，每一个线程都会在主内存中获取一个所需内容的副本，用于自己线程。那么不同的线程之间就会可能出现各自工作内存中同一对象的值不一致问题。</p><h3 id="我们可以对这个现象进行一个模拟："><a href="#我们可以对这个现象进行一个模拟：" class="headerlink" title="我们可以对这个现象进行一个模拟："></a>我们可以对这个现象进行一个模拟：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//线程A</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Waiting&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (!flag)&#123;&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;End waiting....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);    <span class="comment">//确保线程A已经启动</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//线程B</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在控制台处的输出：</p><blockquote><p>Waiting</p></blockquote><p>可见在线程A中的while循环并没有停止，尽管flag的值在表面上已经被线程B修改成了true。</p><p>因此需要在flag前面加上<strong>volatile</strong>修饰，表示该共享变量在多个线程的工作内存之间的可见性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>此时的控制台输出就会和预想的一样：</p><blockquote><p>Waiting</p><p>End waiting….</p></blockquote><h2 id="JMM数据原子操作"><a href="#JMM数据原子操作" class="headerlink" title="JMM数据原子操作"></a>JMM数据原子操作</h2><table><thead><tr><th align="center">操作类型</th><th align="center">解析</th></tr></thead><tbody><tr><td align="center">read（读取）</td><td align="center">从主内存读取数据</td></tr><tr><td align="center">load（载入）</td><td align="center">将主内存读取到的数据写入工作内存</td></tr><tr><td align="center">use（使用）</td><td align="center">从工作内存读取数据来计算</td></tr><tr><td align="center">assign（赋值）</td><td align="center">将计算好的值重新赋值到工作内存中</td></tr><tr><td align="center">store（存储）</td><td align="center">将工作内存数据写入主内存</td></tr><tr><td align="center">write（写入）</td><td align="center">将store过去的变量值赋值给主内存中的变量</td></tr><tr><td align="center">lock（锁定）</td><td align="center">将主内存变量加锁，标识为线程独占状态</td></tr><tr><td align="center">unlock（解锁）</td><td align="center">将主内存变量解锁，解锁后其他线程可以锁定该变量</td></tr></tbody></table><p><img src="https://user-images.githubusercontent.com/17522733/93671584-79025d00-faa4-11ea-91cf-2d876b2bebd9.png" alt="未命名文件 (5)"></p><h2 id="JMM缓存不一致问题"><a href="#JMM缓存不一致问题" class="headerlink" title="JMM缓存不一致问题"></a>JMM缓存不一致问题</h2><p><strong>总线加锁（性能太低，已弃用）</strong>：CPU从主内存读取数据到告诉缓存，会在总线对这个数据加锁，直到用完释放锁之后其他CPU才能访问该数据。本质上已经把并行操作变成了串行操作。</p><p><strong>MESI缓存一致性协议</strong>：多个CPU从主内存读取同一个数据到各自的高速缓存，当其中某个CPU修改了缓存里的数据，该数据会马上同步回主内存，其他<strong>CPU通过总线嗅探机制</strong>可以感知到数据的变化从而将自己缓存里的数据失效。（如上图）</p><h2 id="Volatile可见性底层实现原理"><a href="#Volatile可见性底层实现原理" class="headerlink" title="Volatile可见性底层实现原理"></a>Volatile可见性底层实现原理</h2><p>底层实现主要是通过汇编lock前缀指令，其会锁定这块内存区域的缓存（缓存行锁定）并回写到主内存。这种回写是马上实现的，能保证实时性。</p><p>并发编程三大特性：可见性，原子性，有序性</p><p>volatile保证可见性和有序性，但是不保证原子性。保证原子性需要借助synchronized这样的锁机制。其不保证原子性的原因就在于JMM模型的机制，每个线程有独立的高速缓存，在不加锁的情况下，同时对同一对象进行修改，就会导致缓存不一致的问题。</p>]]></content>
      
      
      <categories>
          
          <category> JMM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM笔记</title>
      <link href="archives/cb80ff62.html"/>
      <url>archives/cb80ff62.html</url>
      
        <content type="html"><![CDATA[<h2 id="常见面试题："><a href="#常见面试题：" class="headerlink" title="常见面试题："></a>常见面试题：</h2><ol><li>请谈谈对JVM的理解？java8虚拟机和之前的变化更新？</li><li>什么是OOM？什么是栈溢出StackOverFlowError？怎么分析？</li><li>JVM的常用调优参数有哪些？</li><li>内存快照如何抓取？怎么分析Dump文件？</li><li>谈谈JVM中，类加载器的认识？</li></ol><a id="more"></a><hr><h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><p>基于操作系统之上，相当于一个环境。</p><hr><h2 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h2><p>下图中绿色区域为线程共享数据，黄色区域为线程私有数据。</p><p><img src="https://user-images.githubusercontent.com/17522733/93140660-1cd5bc80-f6e3-11ea-8057-1746f222bb97.png" alt="未命名文件"></p><p>显然黄色区域的栈、本地方法栈、程序计数器这三个线程私有数据并<strong>不会</strong>有垃圾回收的问题。</p><p>因此所谓的<strong>JVM调优</strong>，都会集中在<strong>堆</strong>和方法区那里，方法区可以看成是一个特殊的堆。</p><p>细化之后是这个样子：</p><p><img src="https://user-images.githubusercontent.com/17522733/93598189-a247be00-f9bc-11ea-8819-9a6816ceb2ef.png" alt="未命名文件 (3)"></p><p>需要注意的是：每个JVM线程拥有一个私有的Java虚拟机栈，创建线程的时候栈也被创建：</p><p><img src="https://user-images.githubusercontent.com/17522733/93720793-8e9e8200-fb8b-11ea-8419-77c2652937c8.png" alt="多线程情况下每个线程拥有一个栈"></p><hr><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>加载.class文件。查看方法是<code>.getClassLoader()</code></p><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><ol><li>类加载器收到类加载的请求</li><li>将这个请求向上委托给父类加载器去完成，一直向上委托直到启动类加载器ROOT</li><li>启动加载器检查是否能够加载当前该类，能加载就搞定结束，否则抛出异常通知子加载器进行加载</li><li>重复步骤3</li></ol><h3 id="类别："><a href="#类别：" class="headerlink" title="类别："></a>类别：</h3><ul><li>虚拟机自带的加载器</li><li>启动类的加载器/根加载器 <code>Bootstrap</code>： <ul><li>用Native代码实现的类加载器。负责将<code>&lt;Java_Runtime_Home&gt;/lib</code>下面的类库加载到内存中(比如rt.jar)。由于引导类加载器涉及到虚拟机本地实现细节，所以开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</li></ul></li><li>扩展类加载器 <code>ExtClassLoader</code>：<ul><li>由Sun的<code>sum.misc.Launcher$ExtClassLoader</code>实现的。负责将<code>&lt;Java_Runtime_Home&gt;/lib/ext</code>或者由系统变量<code>java.ext.dir</code>指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</li></ul></li><li>应用程序加载器 <code>AppClassLoader</code>：<ul><li>由Sun的<code>sum.misc.Launcher$AppClassLoader</code>实现的。负责将系统类路径<code>CLASSPATH</code>中指定的类库加载到内存中。开发者可以直接使用应用程序加载器。</li></ul></li></ul><hr><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，<strong>依次递归</strong>，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p><blockquote><p>白话文描述： 用于保证安全。会逐层往下寻找类的所在包，比如先在ROOT根加载器中找，然后再去EXT扩展类加载器中找，最后在APP应用程序加载器中找，如果APP和ROOT中有同名包，则会优先执行ROOT中的那个。</p></blockquote><p>几点思考：</p><ol><li><p>Java虚拟机的第一个类加载器是Bootstrap，这个加载器很特殊，<strong>它不是Java类，因此它不需要被别人加载，它嵌套在Java虚拟机内核里面，也就是JVM启动的时候Bootstrap就已经启动，它是用C++写的二进制代码（不是字节码）</strong>，它可以去加载别的类。这也是我们在测试时为什么发现<code>System.class.getClassLoader()</code>结果为null的原因，这并不表示System这个类没有类加载器，而是它的加载器比较特殊，是<code>BootstrapClassLoader</code>，由于它不是Java类，因此获得它的引用肯定返回null。</p></li><li><p>双亲委托机制的意义：防止内存中出现多份同样的字节码：</p><p>如果两个类A和类B都要加载System类，如果不用委托而是自己各自加载，那么内存中就会出现两份System字节码。</p><p>在使用委托机制的情况下，两次System类的加载都交给了Bootstrap来处理，就可以防止重复加载的情况发生。</p></li></ol><hr><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>组成沙箱的基本组件：</p><ul><li>字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。帮助实现内存保护。</li><li>类装载器（Class loader）：其在3个方面对Java沙箱其作用：<ul><li>防止恶意代码去干涉善意代码        //双亲委派机制</li><li>守护了被信任的类库边界</li><li>将代码归入保护域，确定了代码可以进行哪些操作</li></ul></li></ul><hr><h2 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h2><p>典型如<code>new Thread().start()</code>函数中有一行：<code>private native void start0();</code> 即为native函数。</p><p>凡是带了native关键字的方法，说明java的作用范围达不到了，会去调用底层C语言的库。这些函数都会进入<strong>本地方法栈</strong>，调用本地方法接口，即JNI。 </p><hr><h2 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h2><p>program counter register</p><p>每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区的方法字节码，在执行引擎读取下一条指令。用于线程切换出去和切换回来时，找到原来的执行位置。</p><hr><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>Method area</p><p>被所有线程共享的，包含所有字段和方法字节码，以及一些特殊方法，比如构造函数，接口代码也在这里定义。即所有定义的方法的信息都保存在这个区域。</p><p><strong>静态变量，常量，类信息（构造方法，接口定义），运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关。</strong></p><hr><h2 id="栈VS堆"><a href="#栈VS堆" class="headerlink" title="栈VS堆"></a>栈VS堆</h2><p>栈：FILO。线程结束，栈内存就释放，故对于栈来说不存在垃圾回收。</p><p>栈运行原理：栈帧。程序正在执行的方法一定在栈的顶部。栈满就会有StackOverFlowError。</p><p>栈，堆的交互关系：栈中的引用指向堆中的对象具体的实例。堆中的常量指向元空间中常量池里的东西。</p><p><img src="https://user-images.githubusercontent.com/17522733/93254468-ab584580-f798-11ea-957d-e6ea90e0d372.png" alt="image-20200915211525421"></p><hr><h2 id="画出在内存中一个对象实例化的过程。"><a href="#画出在内存中一个对象实例化的过程。" class="headerlink" title="画出在内存中一个对象实例化的过程。"></a><strong>画出在内存中一个对象实例化的过程。</strong></h2><p><img src="https://user-images.githubusercontent.com/17522733/93689633-ae24a480-fad0-11ea-9295-9a477beac997.png" alt="在内存中一个对象实例化的过程 (1)"></p><hr><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆内存的大小是可以调节的（调优）。 类的实例，方法，常量，变量等会放在堆中。保存的是引用类型的真实对象。</p><hr><h2 id="新生区VS老年区VS永久区"><a href="#新生区VS老年区VS永久区" class="headerlink" title="新生区VS老年区VS永久区"></a>新生区VS老年区VS永久区</h2><p>新生区：所有的对象都在Eden区诞生。minor gc能留下来的去到了幸存者区(0/1)。 </p><p><img src="https://user-images.githubusercontent.com/17522733/93395012-7110a600-f875-11ea-931c-373cedf73a8e.png" alt="image-20200916233558425"></p><p>在物理实现上，<code>年轻代空间PSYongGen + 老年代空间ParOldGen = Runtime.getRuntime().totalMemory();</code> 也就是说元空间这个东西在逻辑上存在，在物理上不存在。</p><hr><h2 id="堆内存调优"><a href="#堆内存调优" class="headerlink" title="堆内存调优"></a>堆内存调优</h2><h3 id="当遇到OOM的时候，可以："><a href="#当遇到OOM的时候，可以：" class="headerlink" title="当遇到OOM的时候，可以："></a>当遇到OOM的时候，可以：</h3><ol><li>尝试扩大堆内存的空间，比如 <code>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</code></li><li>如果不行的话，分析内存，看一下哪里出现了问题</li></ol><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><ol><li><code>-Xms</code> 设置初始化内存分配大小</li><li><code>-Xmx</code> 设置最大分配内存</li><li><code>-XX:+PrintGCDetails</code>  打印GC垃圾回收信息</li><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>  内存不足时dump</li></ol><h3 id="分析示例："><a href="#分析示例：" class="headerlink" title="分析示例："></a>分析示例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Solution1&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> Solution1());</span><br><span class="line">                count = count+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (OutOfMemoryError error)&#123;</span><br><span class="line">            error.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码示例用于反复产生数组以撑爆堆空间，需要搭配一下的命令参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><p>然后可以在输出窗口看到如下信息：</p><blockquote><p>java.lang.OutOfMemoryError: Java heap space<br>Dumping heap to java_pid24136.hprof …<br>Heap dump file created [7725079 bytes in 0.010 secs]<br>java.lang.OutOfMemoryError: Java heap space<br>    at Solution1.<init>(Solution1.java:4)<br>    at Solution1.main(Solution1.java:10)</p><p>Process finished with exit code 0</p></blockquote><p>在文件管理系统中找到如下文件<code>java_pid24136.hprof</code>，双击可以用<code>jprofiler</code>软件打开，如图</p><p><img src="https://user-images.githubusercontent.com/17522733/93606386-44b96e80-f9c8-11ea-8174-495e05272efd.png" alt="image-20200918155900165"></p><p>可以看到“大对象”中有一个ArrayList很明显很大，点进去<code>Heap Walker --&gt; Thread Dump</code>中可以发现有具体的代码错误提示：</p><p><img src="https://user-images.githubusercontent.com/17522733/93606358-3a977000-f9c8-11ea-85e3-eb46c854042b.png" alt="image-20200918160011353"></p><p>通过这种方法便可以进行分析了。</p><hr><h2 id="GC常用算法"><a href="#GC常用算法" class="headerlink" title="GC常用算法"></a>GC常用算法</h2><ol><li><h3 id="标记清除法-Mark-Sweep"><a href="#标记清除法-Mark-Sweep" class="headerlink" title="标记清除法  Mark-Sweep"></a>标记清除法  Mark-Sweep</h3><p>（1）扫描，对活着的对象进行一个标记。（2）扫描，对没有标记的对象进行清除。</p><p>优点：没有冗余空间</p><p>缺点：两次扫描浪费时间。会产生内存碎片。</p><img src="https://user-images.githubusercontent.com/17522733/93689192-6a2fa080-facc-11ea-9c55-1db938232089.png" alt="image-20200919222636995" style="zoom:80%;" /></li><li><h3 id="标记压缩法-Mark-Compact"><a href="#标记压缩法-Mark-Compact" class="headerlink" title="标记压缩法  Mark-Compact"></a>标记压缩法  Mark-Compact</h3><p>（1）扫描，对活着的对象进行一个标记。（2）扫描，对没有标记的对象进行清除。（3）扫描，将存活的对象移到一侧</p><img src="https://user-images.githubusercontent.com/17522733/93689185-5e43de80-facc-11ea-90dc-88e7c1c0be3b.png" alt="image-20200919222840076" style="zoom:80%;" /></li><li><h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法  Copying"></a>复制算法  Copying</h3><p>主要用于年轻代。对于两个幸存区from和to，谁空谁是to。</p><p>当一个对象经历了15次minor GC都还存活的时候，就会进入老年区。使用命令<code>-XX:MaxTenuringThreshold=5</code>可以修改进入老年区前能抗多少次minor GC。 </p><p><strong>优点</strong>：没有内存的碎片</p><p><strong>缺点</strong>：浪费了内存空间。极端情况下，若对象100%存活，那么每次minor GC的时候都会将幸存区的对象进行一次完整的复制，会有很大的消耗。</p><p>根据优缺点<strong>总结</strong>：复制算法最佳使用场景是对象存活度较低的情况，也就是在新生区。</p><img src="https://user-images.githubusercontent.com/17522733/93689180-51bf8600-facc-11ea-9c7d-eb61f31ec19a.png" alt="image-20200919222729468" style="zoom:80%;" /></li><li><h3 id="引用计数法-Reference-Count"><a href="#引用计数法-Reference-Count" class="headerlink" title="引用计数法  Reference-Count"></a>引用计数法  Reference-Count</h3><p>将对象的使用次数进行标记计数，没用过的就清除。而且这种方法<strong>不能解决循环引用的问题</strong>，比如说如下的这种情况，其实他们都是垃圾，但是由于循环引用的存在，所以无法被回收。</p><img src="https://user-images.githubusercontent.com/17522733/93688369-a1e71a00-fac5-11ea-863e-d4e89e569666.png" alt="GC引用计数法无法解决之循环引用" style="zoom: 50%;" /></li></ol><hr><h2 id="Root-Searching"><a href="#Root-Searching" class="headerlink" title="Root Searching"></a>Root Searching</h2><p><img src="https://user-images.githubusercontent.com/17522733/93688512-a4963f00-fac6-11ea-8359-feb0f15357cc.png" alt="Root Searching"></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>内存效率（时间复杂度）：复制算法 &gt; 标记清除算法 &gt; 标记整理算法</li><li>内存整齐度：复制算法 = 标记整理算法 &gt; 标记清除算法</li><li>内存利用率：标记整理算法 = 标记清除算法 &gt; 复制算法</li><li><strong>适用情况：</strong><ul><li>年轻代：对象存活率低，适用复制算法</li><li>老年代：区域大，存活率高，当内存碎片不过多时适用标记清除算法，当碎片到达一定量时可以搭配使用标记整理算法。（分代收集算法）</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/17522733/93689127-e5dd1d80-facb-11ea-9135-a6748d6c7220.png" alt="垃圾回收器 (2)"></p><hr><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>Java Memory Model</p><p>用于定义数据读写的规则。<a href="https://github.com/ogugugugugua/Java-Notes/blob/master/note/JMM.md">https://github.com/ogugugugugua/Java-Notes/blob/master/note/JMM.md</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 堆栈 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类</title>
      <link href="archives/aef82664.html"/>
      <url>archives/aef82664.html</url>
      
        <content type="html"><![CDATA[<p>摘要：Collection类，StringBuilder和StringBuffer，HashMap原理，HashMap源码</p><a id="more"></a><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="https://img-blog.csdnimg.cn/20190122191848295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxeHg2NjYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>数组和集合的区别：</p><blockquote><p>数组的长度固定。</p><p>集合的长度可变。</p></blockquote><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>集合的的最大目的就是为了存取；List集合的特点就是存取有序，可以存储重复的元素，可以用下标进行元素的操作</p><ul><li><p>ArrayList    底层是使用数组实现，所以查询速度快，增删速度慢</p></li><li><p>LinkedList  是基于链表结构实现的，所以查询速度慢，增删速度快，提供了特殊的方法，对头尾的元素操作（进行增删查）</p></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>队列是一种特殊的线性表，只允许在表的前端进行删除操作，而在表的后端进行插入操作。我们可以把LinkedList当做Queue来用，因为其实现了Queue接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//add()和remove()方法在失败的时候会抛出异常(不推荐)</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        queue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        queue.offer(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        queue.offer(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        queue.offer(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        queue.offer(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;poll=&quot;</span>+queue.poll()); <span class="comment">//返回第一个元素，并在队列中删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;element=&quot;</span>+queue.element()); <span class="comment">//返回第一个元素 </span></span><br><span class="line">        System.out.println(<span class="string">&quot;peek=&quot;</span>+queue.peek()); <span class="comment">//返回第一个元素 </span></span><br><span class="line">        <span class="keyword">for</span>(String q : queue)&#123;</span><br><span class="line">            System.out.println(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>offer，add 区别：</strong></p><p>一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。</p><p>这时新的 offer 方法就可以起作用了。它不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。</p><p><strong>poll，remove 区别：</strong></p><p>remove() 和 poll() 方法都是从队列中删除第一个元素。remove() 的行为与 Collection 接口的版本相似， 但是新的 poll() 方法在用空集合调用时不是抛出异常，只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p><p><strong>peek，element区别：</strong></p><p>element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</p><p><strong>总结：使用offer来增加，poll来删除，peek来查询。</strong></p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h2 id="StringBuilder-StringBuffer"><a href="#StringBuilder-StringBuffer" class="headerlink" title="StringBuilder/StringBuffer"></a>StringBuilder/StringBuffer</h2><p>用于多次修改字符串，而不产生新的未使用对象。</p><blockquote><p>StringBuilder:速度快，线程不安全。StringBuffer反过来。</p><p>public StringBuffer append(String s) 将指定的字符串追加到此字符序列。</p><p> public StringBuffer reverse()  将此字符序列用其反转形式取代。</p><p>public delete(int start, int end) 移除此序列的子字符串中的字符。</p><p> public insert(int offset, int i) 将 <code>int</code> 参数的字符串表示形式插入此序列中。</p><p> replace(int start, int end, String str) 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</p></blockquote><h2 id="Hash相关"><a href="#Hash相关" class="headerlink" title="Hash相关"></a>Hash相关</h2><h3 id="Hash表简介"><a href="#Hash表简介" class="headerlink" title="Hash表简介"></a>Hash表简介</h3><blockquote><p>非Hash表的特点是：<code>关键字key</code> 与 <code>其在表中的位置</code> 不存在一个确定关系。因此搜索效率取决于比较的次数。</p><p>Hash表的特点是：<code>关键字key</code> 与 <code>其在表中的位置</code> 存在一个确定的关系。</p></blockquote><p>Hash函数：用于建立 <code>关键字key</code> 与 <code>其在表中的位置</code> 的函数关系，比如<code>f(key)=key在表中的位置</code>，那么<code>f</code>即为Hash函数。</p><p>这种函数就是将任意长度的输入，变成固定长度的输出(即散列值)。显然是一种压缩映射，即Space(输入)&gt;&gt;Space(输出散列值)，因此不可能从散列值来唯一地确定输入值。</p><p>上面的原因导致会产生<code>Hash冲突</code>，即 <code>f(key2)==f(key1)，当key2!=key1</code>。</p><p><img src="https://user-images.githubusercontent.com/17522733/92412248-79693280-f14b-11ea-98b2-c789b5a1ee62.png" alt="image-20200906231421217"></p><hr><p>HashMap和HashTable的区别</p><p><img src="https://img-blog.csdnimg.cn/20190122192155107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxeHg2NjYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h3 id="在Java中具体的HashMap实现："><a href="#在Java中具体的HashMap实现：" class="headerlink" title="在Java中具体的HashMap实现："></a>在Java中具体的HashMap实现：</h3><p>HashMap实际是一种“<strong>数组+链表</strong>”数据结构。在put操作中，通过内部定义算法寻止找到数组下标，将数据直接放入此数组元素中，若通过算法得到的该数组元素已经有了元素（俗称hash冲突，链表结构出现的实际意义也就是为了解决hash冲突的问题）。将会把这个数组元素上的链表进行遍历，将新的数据放到链表末尾。</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167cf3bc35bcc29e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>上面看到的这些Node的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;<span class="comment">//存储数据的key</span></span><br><span class="line">        V value;<span class="comment">//存储数据的Value</span></span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">//下一个数据，出现哈希冲突时，该数组元素会出现链表结构，会使用next指向链表中下一个元素对象        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap的put方法详解："><a href="#HashMap的put方法详解：" class="headerlink" title="HashMap的put方法详解："></a>HashMap的put方法详解：</h3><blockquote><p>1、首选判断table是否为空，数组长度为空，将会进行第一次初始化。（在实例化HashMap是，并不会进行初始化数组）</p><p>2、进行第一次resize()扩容之后。开始通过hash算法寻址找到数组下标。若数组元素为空，则创建新的数组元素。若数组元素不为空，同时hash相等，key不相等，同时不是TreeNode数据对象，将遍历该数组元素下的链表元素。若找到对应的元素，则覆盖，如果没有找到，就新建元素，放入上一个链表元素的next中，在放入元素之后，如果条件满足”链表元素长度&gt;8”，则将该链表结构转为”红黑树结构”。</p><p>3、找到对应的数组元素或者链表元素，同时创建新的数据元素或者覆盖元素之后。如果条件满足元素大小size&gt;允许的最大元素数量threshold，则再一次进行扩容操作。每次扩容操作，新的数组大小将是原始的数组长度的两倍。</p><p>4、put操作完成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 判断数组table是否为空，长度是否为0，是则进行扩容数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 通过hash算法找到数组下标得到数组元素，为空则新建</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//新建即直接插入该键值对</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">             <span class="comment">// 找到数组元素，hash相等同时key相等，则直接覆盖value</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// key不相等，判断该数组元素是否对应为红黑树结构的对象</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); <span class="comment">//如果是则直接插入键值对</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 该数组元素hash相等，key不等，同时链表长度&lt;8.进行遍历寻找元素，有就覆盖无则新建</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 新建链表中数据元素</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);<span class="comment">// 链表长度&gt;=8 结构转为 红黑树</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize(); <span class="comment">//扩容</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167cf3bc3724604a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><hr><h3 id="HashMap的get方法详解："><a href="#HashMap的get方法详解：" class="headerlink" title="HashMap的get方法详解："></a>HashMap的get方法详解：</h3><p>通过目标key的hashCode和寻址算法得到数组下标，若数组元素中的key，hash分别和目标的一致，则直接返回。若不相等，则在链表或者红黑树中进行匹配寻找并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node，先判断hash相等</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//再判断key相等</span></span><br><span class="line">                <span class="keyword">return</span> first; <span class="comment">//相等则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;<span class="comment">//存在链表或红黑树结构</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)<span class="comment">//判断是否为红黑树</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<span class="comment">//直接在树中进行匹配</span></span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">//这段是在链表中进行匹配</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; <span class="comment">//先判断hash相等</span></span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//再判断key相等</span></span><br><span class="line">                        <span class="keyword">return</span> e; <span class="comment">//相等则返回</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="HashMap的扩容resize方法简介："><a href="#HashMap的扩容resize方法简介：" class="headerlink" title="HashMap的扩容resize方法简介："></a>HashMap的扩容resize方法简介：</h3><p>由于扩容后需要把键值对重新放到对应的位置，这里使用一个特殊机制，以简化重新计算位置的操作：</p><p>假设原数组长度capacity为16，扩容后new capacity为32：</p><blockquote><p>capacity        : 00010000</p><p>new capacity : 00100000</p></blockquote><p>对于一个key，如果其hashCode在第5位为0，则取模后结果不变。如果为1，则得到的结果为原来结果+16。</p><p>总结：经过重新哈希rehash之后，元素的位置要么在原位置，要么在原位置再移动2次幂的位置。</p><p><img src="https://img-blog.csdnimg.cn/20190122192145386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxeHg2NjYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h3 id="Hash冲突处理方法"><a href="#Hash冲突处理方法" class="headerlink" title="Hash冲突处理方法"></a>Hash冲突处理方法</h3><h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>m为表的长度</p><p>冲突后对增量di的三种取值方法：</p><ul><li><p>线性探测再散列：<br>$$<br>di = 1,2,3,…,m-1<br>$$</p></li><li><p>平方探测再散列：<br>$$<br>di = +1^2 , -1^2, +2^2, -2^2, +3^2, -3^2, …, +k^2, -k^2<br>$$</p></li><li></li><li><p>随机探测再散列：<br>$$<br>di = 伪随机数列<br>$$</p></li></ul><p><img src="https://user-images.githubusercontent.com/17522733/92412270-93a31080-f14b-11ea-942a-ef12e9b8715d.png" alt="image-20200906232425870"></p><hr><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><h3 id="与Java集合框架相关的有哪些最好的实践"><a href="#与Java集合框架相关的有哪些最好的实践" class="headerlink" title="与Java集合框架相关的有哪些最好的实践"></a>与Java集合框架相关的有哪些最好的实践</h3><p>如果是单列的集合，我们考虑用Collection下的子接口ArrayList和Set。</p><p>如果是映射，我们就考虑使用Map</p><ul><li>是否需要同步：去找线程安全的集合类使用</li><li>迭代时是否需要有序(插入顺序有序)：去找Linked双向列表结构的</li><li>是否需要排序(自然顺序或者手动排序)：去找Tree红黑树类型的(JDK1.8)</li><li>估算存放集合的数据量有多大，无论是List还是Map，它们实现动态增长，都是有性能消耗的。在初始集合的时候给出一个合理的容量会减少动态增长时的消耗</li><li>使用泛型，避免在运行时出现ClassCastException</li><li>尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性</li></ul><hr><h3 id="LeetCode经验"><a href="#LeetCode经验" class="headerlink" title="LeetCode经验"></a>LeetCode经验</h3><p>HashMap通常可以用于优化需要遍历两个集合，这两个集合之间元素有一定共同点的情况下。这种情况下使用原始的方法一般需要一个两层for循环来进行遍历，优化后可以变位两个一层for循环。</p><p>比如说需要匹配两个集合间所有ID一样的项，或者说需要分别找到两个元素之和为常数的情况。优化的步骤一般是将其中一个集合放进HashMap里面，value是元素本身，key是需要匹配的那个xxx东西（元素下标，ID，等等……）。然后对另一个集合做for循环遍历，里面使用<code>if (map.containsKey(xxx))</code> 来判断是否找到需要的元素，由于map的搜索是O(1)的时间，所以很快。</p><p>参考<a href="https://segmentfault.com/a/1190000018033013">https://segmentfault.com/a/1190000018033013</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> HashMap </tag>
            
            <tag> Collection </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Présentation personnelle en Français pour la recherche d&#39;un stage en 2021</title>
      <link href="archives/9d758c05.html"/>
      <url>archives/9d758c05.html</url>
      
        <content type="html"><![CDATA[<p>Présentation:</p><p>Bonjour, je suis Yulin XIE, je viens de la Chine. Et je suis arrivé en France il y a un ans pour mes études d’ingénieur dans Polytech Nantes. Ma spécialité est informatique, maintenant  je me focalise principalement sur le développement Java, et aussi le javascript. </p><a id="more"></a><p>Pendant le confinement de cette année, j’ai dépensé beaucoup de temps à m’enrichir concernant plusieurs technique de développement; Afin de mettre en pratique les théories, j’ai développé un site é-commerce en utilisant les Framework liés à Spring. Vous pouvez cliquer le lien pour voir ce qu’il y a dedans, désolé pour l’instant c’est seulement en chinois mais je vais bientôt faire l’internationalisation pour que tout le monde puisse comprendre. </p><p>En plus de cet projet personnel, j’ai aussi fait quelque projets quand j’étais en chine et aussi un projet transversal ici en France. </p><p>Le projet transversal a été fait en collaboration avec un ancien élève de Polytech Nantes, l’objective est de mettre en place un démo de classification des mails pour vérifier la fonctionnalité d’une interface de développement en intélligence artificielle qui s’appelle Hyperplan. Je m’occupe de la partie de l’implémentation des algos de classification, dans laquelle j’ai implémenté trois solutions de différents niveaux. En plus, on a fourni des retours pour l’amélioration de l’interface.</p><p>Pour les trois méthodes de classification, tout d’abord c’est un algo qui s’appelle TF-IDF, ou bien term frequency–inverse document frequency. Une technique de la récupération d’informations et exploration de données,largement utilisé pour trouver des mots clés dans un article. Le deuxième est le k-means, un algo de machine learning non supervisé pour catégoriser les étiquettes des articles. Et enfin le textCNN, un algo de deep learning supervisé pour classifier les texte en utilisant le réseau de neurone convolutionelle. </p><p>Pour la durée du stage, je serai disponible à partir de 18 février et jusqu’à fin aout. Et je dépose une voiture ici donc il n’y a pas de soucis concernant les mobilisation de Nantes à Rennes. </p>]]></content>
      
      
      <categories>
          
          <category> Français </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Français </tag>
            
            <tag> stage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发8</title>
      <link href="archives/39d1bb55.html"/>
      <url>archives/39d1bb55.html</url>
      
        <content type="html"><![CDATA[<p>摘要：Executors，ThreadPoolExecutors源码，ForkPoolJoin</p><a id="more"></a><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>可以看成是线程池的工厂。可以返回各种线程池。</p><p>何时用Cached何时用Fixed？</p><blockquote><p>对于任务的到来具有峰谷值的情况下推荐用Cached，而对于任务的到来比较平缓的情况推荐使用Fixed。</p></blockquote><hr><h2 id="单线程的线程池"><a href="#单线程的线程池" class="headerlink" title="单线程的线程池"></a>单线程的线程池</h2><p>单线程的线程池<code>Executors.newSingleThreadExecutor()</code>可以保证进去的任务被顺序执行。而且其内部帮忙维护了任务队列，就蛮好的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="comment">//核心线程数是1，最大线程数也是1</span></span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="comment">//非核心线程存活时间为0，因为没有非核心线程</span></span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<span class="comment">//最大长度为Integer.MAX_VALUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存线程池"><a href="#缓存线程池" class="headerlink" title="缓存线程池"></a>缓存线程池</h2><p><code>Executors.newCachedThreadPool()</code>的特点是：在线程数量少于Integer.MAX_VALUE的情况下，来一个任务就会起一个新的线程来执行。存货时间是60秒。实现的原理是任务队列类型为SynchronousQueue，其容量为0，如果没有take掉的话就会处于阻塞状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="comment">//核心线程数是0，最大线程数是Integer.MAX_VALUE</span></span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,<span class="comment">//非核心线程存活时间为60秒</span></span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<span class="comment">//任务队列类型为SynchronousQueue，来一个执行一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于定时任务线程池，可以使用<code>Executors.newScheduledThreadPool()</code>，也推荐使用quartz或者cron这两种工具。</p><hr><h2 id="并行VS并发："><a href="#并行VS并发：" class="headerlink" title="并行VS并发："></a>并行VS并发：</h2><blockquote><p>并发指任务提交，并行指任务执行。</p></blockquote><hr><h2 id="ThreadPoolExecutor源码解析"><a href="#ThreadPoolExecutor源码解析" class="headerlink" title="ThreadPoolExecutor源码解析"></a>ThreadPoolExecutor源码解析</h2><p>从上面的源码可以看出来，其底层的线程池创建还是调用了ThreadPoolExecutor函数，现在来看看它的源码：</p><p>常用变量的解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. ctl 可以看做一个int类型的数字，高3位代表线程池状态，低29位代表worker数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//2. 这个数是32-3=29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//3. 线程池允许的最大线程数，即2^29-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">//4. 线程池有5种状态，按大小排序为RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING&lt; TERMINATED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>构造方法并没有太多新意，主要是检查参数是否合法以及是否为空，然后进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">    maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">    maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">    keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br></pre></td></tr></table></figure><h3 id="执行提交的task的过程"><a href="#执行提交的task的过程" class="headerlink" title="执行提交的task的过程"></a>执行提交的task的过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//worker数量比核心线程数小，直接创建worker执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();<span class="comment">//由于多线程的缘故，需要再次取值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//worker数量超过核心线程数，任务直接进入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//若线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject操作</span></span><br><span class="line">        <span class="comment">//这里做recheck的原因是任务进入队列前后，线程池的状态可能会发生改变</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//若检查可用的核心线程数为0，则增加非核心线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor的execute方法执行过程总结："><a href="#ThreadPoolExecutor的execute方法执行过程总结：" class="headerlink" title="ThreadPoolExecutor的execute方法执行过程总结："></a><strong>ThreadPoolExecutor的execute方法执行过程总结</strong>：</h2><ol><li>核心线程数不够：新增核心线程。</li><li>核心线程数够了：加队列。</li><li>核心线程够了 &amp;&amp; 队列满了： 新增非核心线程。</li></ol><p>流程图如下：</p><p><img src="https://user-images.githubusercontent.com/17522733/98036969-2e059480-1e1b-11eb-98b2-1b2304c4bf2f.png" alt="ThreadPoolExecutor java public void execute(Runnable command) 源码流程图即对应代码 (1)"></p><hr><p>addWorker可以理解为添加线程的函数：</p><p>​    count++； 真的增加一个worker并start；</p><hr><p>worker本身是一个Runnable的子类。进来到线程池里的任务用worker来包装一下。因为里面有很多的状态需要记录，比如有一个成员变量thread用于记录当前任务所处的线程。</p><hr><h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><p><a href="https://github.com/ogugugugugua/Java-Notes/blob/1056bd9cd0ecb1557599bf73977c333ad0d6c39e/code/multiThread/src/com/threadPool/testForkJoinPool.java">ForkJoinPool</a>适合处理将大任务分解成小任务的情况。先分叉再汇总。</p><p>首先需要定义适合这种线程池处理的任务，底层一点的有ForkJoinTask，常用的它的子类有RecursiveAction（不带返回值）和RecursiveTask（带返回值）。</p><hr><p>Executors.netWorkStealingPool() 是ForkJoin类型的线程池。</p><p>特点：每个线程有自己单独的队列！</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 源码 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发7</title>
      <link href="archives/a96ea6c4.html"/>
      <url>archives/a96ea6c4.html</url>
      
        <content type="html"><![CDATA[<p>摘要：线程池图解，FutureTask，ThreadPoolExecutor</p><a id="more"></a><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote><p>上层有Executor接口，中间有ExecutorService接口，下层有ThreadPoolExecutor类。</p></blockquote><p>我们使用Callable接口可以定义类似于Runnable功能的任务，然后交给线程去执行。区别在于Callable具有返回值，而且其使用场景一般与线程池相关。</p><p>由于Callable提交给线程池之后的执行是相对主线程异步的，所以我们可以把Callable将来执行产生的结果存储在Future这个类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;enter callable&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">    Future&lt;String&gt; future = service.submit(callable);<span class="comment">//异步的</span></span><br><span class="line">    System.out.println(future.get());<span class="comment">//阻塞的，因此会等1秒才得到输出</span></span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>相当于一个任务，此任务完成之后的结果页存储在其之中。其实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable和Future两个接口。很灵活：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;enter future task&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    System.out.println(task.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>可以近似理解成多个Future的管理类。一个很有意思的应用是：在多个网站上使用多个线程同步拉取数据，当这些线程把任务都执行完之后，继续主线程，代码在<a href="https://github.com/ogugugugugua/Java-Notes/blob/c54b05757bf18a7db3d95af93808e8b249ba0f81/code/multiThread/src/com/threadPool/testCompletableFuture.java">仓库</a>。</p><p>在这里我们能很明显地看到CompletableFuture对于管理多个Future是很有效的，典型API如<code>allof</code>或者<code>anyof</code>用来指定当<code>全部</code>或者<code>其中之一</code>的任务完成时才做接下来的工作。</p><hr><h2 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h2><ol><li>ThreadPoolExecutor</li><li>ForkJoinPool：<ol><li>用于分解汇总的任务</li><li>用很少的线程可以执行很多的任务（子任务），而ThreadPoolExecutor做不到先执行子任务</li><li>CPU密集型</li></ol></li></ol><p><img src="https://user-images.githubusercontent.com/17522733/98050291-a6775000-1e31-11eb-9dcc-f977979dfd66.png" alt="两种线程池"></p><p><strong>阿里手册中要求线程池要自定义。</strong></p><p><strong>线程池维护着两个集合：线程的集合 &amp;&amp; 任务的集合。</strong></p><hr><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>与上层接口的关系：</p><p><img src="https://user-images.githubusercontent.com/17522733/97914181-c6364780-1d4f-11eb-86b5-c25fbdf42045.png" alt="image-20201102210928195"></p><p>其自定义初始化需要有7个参数【背】：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程数(不归还给操作系统)</span></span></span><br><span class="line"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,<span class="comment">//最大线程数(扩容的最大值)</span></span></span><br><span class="line"><span class="function">                          <span class="keyword">long</span> keepAliveTime,<span class="comment">//空闲线程存活时间数值</span></span></span><br><span class="line"><span class="function">                          TimeUnit unit,<span class="comment">//存活时间单位</span></span></span><br><span class="line"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">//任务队列(类型是阻塞队列)</span></span></span><br><span class="line"><span class="function">                          ThreadFactory threadFactory, <span class="comment">//线程工厂 (产生什么类型的线程等)</span></span></span><br><span class="line"><span class="function">                          RejectedExecutionHandler handler) <span class="comment">//拒绝策略</span></span></span><br></pre></td></tr></table></figure><p>对于第5个参数，能够在某种程度上决定这个线程池的一些特点，比如：假设我们使用SynchrnousQueue，就会来一个任务则马上被处理，因为其容量为0。</p><p>对于第6个参数，我们可以自定义线程工厂。【阿里：创建线程或线程池时请指定有意义的线程名称，方便出错时回溯】。在<code>Executors.java</code>里面有一个<code>static class DefaultThreadFactory implements ThreadFactory</code>默认线程工厂，其中的核心函数<code>newThread</code>就会指定线程的名字。</p><blockquote><p>阿里手册中，线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式能够更加明确线程池的运行规则，避免资源耗尽的风险。是<strong>因为</strong>：FixedThreadPool和SingleThreadPool允许的<strong>请求队列长度</strong>为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。CachedThreadPool允许的<strong>创建线程数量</strong>为Integer.MAX_VALUE，可能会创建大量的线程，从而也导致OOM。</p></blockquote><p>啊！</p><p>对于第7个参数拒绝策略，默认有4种，在真实场景中往往会自定义。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发6</title>
      <link href="archives/de699652.html"/>
      <url>archives/de699652.html</url>
      
        <content type="html"><![CDATA[<p>摘要：容器，阻塞队列，源码解析</p><a id="more"></a><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>在物理结构上只有两种：连续存储（数组）和非连续存储（链表）</p><p>按照编排方式可以按下图的方式进行分离：<strong>【背好】</strong></p><p><img src="https://user-images.githubusercontent.com/17522733/97811254-9583de80-1c79-11eb-87be-708336293afd.png"></p><p>这个BlockingQueue阻塞队列主要服务于高并发的任务。</p><p>Deque是双端队列。</p><p>Vector和HashTable的很多操作都加了synchronized，所以在一定程度上性能一般般。</p><hr><h2 id="HashMap-amp-amp-HashTable-amp-amp-ConcurrentHashMap"><a href="#HashMap-amp-amp-HashTable-amp-amp-ConcurrentHashMap" class="headerlink" title="HashMap &amp;&amp; HashTable &amp;&amp; ConcurrentHashMap"></a>HashMap &amp;&amp; HashTable &amp;&amp; ConcurrentHashMap</h2><p>HashMap没有加synchronized，所以它不是线程安全的。</p><p>通过Collections.synchronizedMap(new HashMap&lt;&gt;());可以获得线程安全的HashMap。在底层实现上依旧是加了synchronized。</p><p>目前来说HashTable和Vector基本不用。</p><p>现在有一个<strong>读效率</strong>更高的ConcurrentHashMap。</p><p><strong>注意</strong>：上述的这些Map并不是绝对的替代关系，因为CAS和synchronized没有绝对的优劣之分，要根据实际情况下并发量的大小和并发代码的执行时间进行具体的判断。</p><hr><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>注意：即使使用了线程安全的容器比如vector，依然有可能会出现问题，比如我们调用了synchronized的size方法判断大小之后，再调用synchronized的remove方法去除元素，但是中间可能会有别的线程对容器进行干预，也就是说两个原子操作之间并不能保证原子性。</p><p>解决办法：使用ConcurrentLinkedQueue（对应remove的是poll方法）。以后对于单个元素的集合，尽量考虑Queue集合而不是List集合，因为其对高并发具有更好的支持。</p><p>查看源码可以发现ConcurrentLinkedQueue的底层原子性是通过CAS来实现的，所以其效率很高。</p><hr><h2 id="TreeMap-amp-amp-ConcurrentSkipListMap"><a href="#TreeMap-amp-amp-ConcurrentSkipListMap" class="headerlink" title="TreeMap &amp;&amp; ConcurrentSkipListMap"></a>TreeMap &amp;&amp; ConcurrentSkipListMap</h2><p>TreeMap使用红黑树实现，内部已排序，在查找的时候效率高。</p><p>ConcurrentSkipListMap支持高并发而且排序。通过跳表来实现。（代替了不存在的ConcurrentTreeMap）</p><p>跳表的结构是这样的：</p><p><img src="https://www.xstnet.com/uploads/images/2019-09/b7ec1e2fa4791f9a16e5bd661fc50040.png"></p><p>最底层基础的还是一个链表结构，然后在其上层逐步进行抽象，只拿下层的若干个关键节点，这样有利于减少查询次数。</p><hr><h2 id="CopyOnWriteList-CopyOnWriteSet-写时复制"><a href="#CopyOnWriteList-CopyOnWriteSet-写时复制" class="headerlink" title="CopyOnWriteList / CopyOnWriteSet 写时复制"></a>CopyOnWriteList / CopyOnWriteSet 写时复制</h2><p>应用场景：写得少，读得多。（因为这个结构在读的时候不加锁，写的时候进行一波复制）</p><p>这个东西的源码非常容易理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个元素：Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//锁上</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;<span class="comment">//获取原数组长度</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//复制一个新数组，并指定长度加一</span></span><br><span class="line">        newElements[len] = e;<span class="comment">//设定最新添加的元素在末位</span></span><br><span class="line">        setArray(newElements);<span class="comment">//更改引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除一个元素Removes the element at the specified position in this list. Shifts any subsequent elements to the left</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//锁上</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;<span class="comment">//获取原数组长度</span></span><br><span class="line">        E oldValue = get(elements, index);<span class="comment">//获取被删除的元素</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;<span class="comment">//计算index后方需要移动的元素个数</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)<span class="comment">//index后方需要移动的元素个数为0，即删除了最后一个元素</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));<span class="comment">//直接把整个数组复制到新的数组里并忽略最后一位即可</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];<span class="comment">//先new一个新的数组</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);<span class="comment">//复制前半部分</span></span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index, numMoved);<span class="comment">//复制后半部分</span></span><br><span class="line">            setArray(newElements);<span class="comment">//指向新的引用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;<span class="comment">//返回被删除的元素</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="BlockingQueue-阻塞队列"><a href="#BlockingQueue-阻塞队列" class="headerlink" title="BlockingQueue 阻塞队列"></a>BlockingQueue 阻塞队列</h2><p>重点在“阻塞”上。有以下几种：</p><ul><li>DelayBlockingQueue可以实现在时间上的排序。</li><li>ArrayBlockingQueue有界的。</li><li>LinkedBlockingQueue无界的。</li><li>SynchronousQueue一般用于线程间传递任务。</li><li>TransferQueue也同于线程间传递任务，可以传多个。</li></ul><hr><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>关于Queue这个类的方法，一般常用offer来增加，用peek来查看顶端，poll来查看并删除顶端。</p><p>对于BlockingQueue这个接口而言，会有以下的方法：</p><ol><li>添加元素：</li></ol><ul><li>add：有位置则增加，如果满了就会报错</li><li>offer：有位置则增加，如果满了就会返回false</li><li>put：有位置则增加，如果满了就会阻塞到有位置再增加</li></ul><ol start="2"><li>删除元素：</li></ol><ul><li>remove：有对应元素则删除并返回true，否则返回false</li><li>poll(long timeout, TimeUnit unit)：返回并删除队列的头节点，等待时间超过unit之后就会有中断异常</li><li>take：返回并删除队列的头结点，如果队列为空则阻塞直到有值可以返回</li></ul><p>显然这种BlockingQueue就是天生对线程安全的生产着消费者模型</p><p>比如我们可以看LinkedBlockingQueue的put方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类成员</span></span><br><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the tail of this queue, waiting if</span></span><br><span class="line"><span class="comment"> * necessary for space to become available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);<span class="comment">//即将放进去的Node节点</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;<span class="comment">//当前元素个数</span></span><br><span class="line">    putLock.lockInterruptibly();<span class="comment">//锁上</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();<span class="comment">//满了就等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);<span class="comment">//放进去</span></span><br><span class="line">        c = count.getAndIncrement(); <span class="comment">//当前元素个数是之前个数+1</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();<span class="comment">//加完之后还没满，可以让其他等待着的线程继续添加元素</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();<span class="comment">//加完之后就刚好不空了，唤醒那些等待着take的线程来取元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而ArrayBlockingQueue可以指定容量capacity，满了的时候如果使用put方法就会阻塞，同理满了的时候使用add就会抛出异常。</p><hr><h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a><strong>总结一下</strong>：</h3><ul><li>Queue和List这两个集合的区别主要在于对于多线程的支持，提供了很多友好的API，比如offer，peek，poll。</li><li>Queue的子类BlockingQueue又添加了一些与阻塞相关的API，比如take，put。</li></ul><hr><h2 id="几个特殊一些的BlockingQueue"><a href="#几个特殊一些的BlockingQueue" class="headerlink" title="几个特殊一些的BlockingQueue"></a>几个特殊一些的BlockingQueue</h2><p><strong>DelayQueue</strong>可以按照在里面等待的时间进行排序。本质上使用的是PriorityQueue，应用场景：按照时间进行任务调度。</p><p><strong>SynchrnousQueue</strong>的使用场景类似于Exchanger。需要有一个线程在阻塞着等take拿数据时候，才可以另一个线程往里面put放数据，否则无法放进去。内部无法存储元素，当要添加元素的时候，需要阻塞。</p><p><strong>LinkedTransferQueue</strong>可以算是 <code>LinkedBolckingQueue</code> 和 <code>SynchronousQueue</code> 和合体。<code>LinkedTransferQueue</code>是 <code>SynchronousQueue</code> 和 <code>LinkedBlockingQueue</code> 的合体，性能比 <code>LinkedBlockingQueue</code> 更高（没有锁操作），比 <code>SynchronousQueue</code>能存储更多的元素。</p><p>当 <code>put</code> 时，如果有等待的线程，就直接将元素 “交给” 等待者， 否则直接进入队列。    </p><p><code>put</code>和 <code>transfer</code> 方法的区别是，put 是立即返回的， transfer 是阻塞等待消费者拿到数据才返回。<code>transfer</code>方法和 <code>SynchronousQueue</code>的 put 方法类似。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 多线程 </tag>
            
            <tag> Java容器 </tag>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发5</title>
      <link href="archives/4760c7e8.html"/>
      <url>archives/4760c7e8.html</url>
      
        <content type="html"><![CDATA[<p>摘要：ThreadLocal，Java引用类型</p><a id="more"></a><h2 id="varHandle"><a href="#varHandle" class="headerlink" title="varHandle"></a>varHandle</h2><p>可以用于获取某个对象的引用，其具有两个有意思的特点：</p><ol><li>可以对普通属性进行原子操作。</li><li>比反射快，直接操纵二进制码</li></ol><hr><h2 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h2><p>允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量。</p><p>数据库声明式事务可以用到，以保证多个事务用到的是同一个连接：在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此在多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有属于自己的连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某个线程首次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。</p><p>从概念上看，可以将ThreadLocal<T> 看成包含了Map&lt;Thread, T&gt;对象，其中保存了特定于该线程的值。</p><p>如果需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象，可以维持线程安全性。</p><hr><h2 id="Java的四种引用："><a href="#Java的四种引用：" class="headerlink" title="Java的四种引用："></a>Java的四种引用：</h2><p>强软弱虚</p><ol><li><p>普通的引用就是强引用。被强引用的对象显然不会被GC回收</p></li><li><p>软引用SoftReference。当一个内存被软引用指向，只有当空间不够用的时候才会被回收。用途：可以用在缓存，比如缓存一个大图片。</p></li><li><p>弱引用WeakReference。只要遇到GC就会被回收。一般用在容器里。如WeakHashMap。一个典型的应用就是ThreadLocal。</p></li><li><p>虚引用PhantomReference管理堆外内存。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 多线程 </tag>
            
            <tag> ThreadLocal </tag>
            
            <tag> Java引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发4</title>
      <link href="archives/3067f77e.html"/>
      <url>archives/3067f77e.html</url>
      
        <content type="html"><![CDATA[<p>摘要：面试题，Condition，AQS</p><a id="more"></a><blockquote><p><a href="https://github.com/ogugugugugua/Java-Notes/tree/2237b94422e32529f6a1825a3023975be95c560c/code/multiThread/src/com/interviewExercises/ex1">淘宝面试题1</a>：实现一个容器，提供两个方法add size，写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</p></blockquote><p><strong>解法详解：</strong></p><ul><li>T01并不能用，因为线程1更改的内容对于线程2来说并不可见。</li><li>T02和T03本质上属于在T01基础上增加了volatile关键字，虽然可行但是很奇怪：volatile修饰的是指向内存地址的指针，而这个指针是不会随着内存中值的修改而变化的，所以并不能合理地解释为什么线程1修改的值能够及时让线程2感知到。暂时放下不表。</li><li>T04也不能用。因为notify不释放锁，所以线程1即使唤醒了线程2，但是并没有释放掉锁，线程2只能等着。</li><li>T05是真正可用的版本，需要背下来，这是最基础原始的写法。线程1在容器到达指定size的时候通知线程2的同时需要把自己停掉，等线程2执行完之后再唤醒线程1。</li><li>T06与T05在思想上高度雷同，但是使用了两个CountDownLatch这个工具，使得原来的wait方法变成了latch.wait，原来的notify方法变成了latch.countDown方法。</li><li>T07是最简洁的版本，同样与T05在思想上高度雷同，使用了LockSupport工具，使用park方法代替wait来停住自己，使用unpark方法代替notify来唤醒另外一个线程。</li></ul><hr><blockquote><p><a href="https://github.com/ogugugugugua/Java-Notes/tree/2237b94422e32529f6a1825a3023975be95c560c/code/multiThread/src/com/interviewExercises/ex2">淘宝面试题2</a>：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程和10个消费者线程的阻塞调用。</p></blockquote><ul><li>这是经典的题目，需要直接<strong>背</strong>好解题。</li><li>需要注意的是需要使用while来判断当前size和最大/最小限制的关系。</li><li>T01是比较高效的版本，由于引入了Condition这个工具，只会唤醒指定线程队列里面的等待队列。</li></ul><hr><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>unpark可以在park前调用，以失效即将到来的park。可以看出比wait和notify更灵活。</p><hr><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>本质就是等待队列！</p><hr><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AbstractQueuedSynchronizer 是很<strong>重要</strong>的类，需要仔细阅读源码</p><p>模板方法 钩子函数; template method, callback function</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> JavaSE </tag>
            
            <tag> 多线程 </tag>
            
            <tag> JUC </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发3</title>
      <link href="archives/ae0362dd.html"/>
      <url>archives/ae0362dd.html</url>
      
        <content type="html"><![CDATA[<p>摘要：LongAdder ，ReentrantLock，CyclicBarrier，读写锁ReadWriteLock，semaphore</p><a id="more"></a><h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><p>分段锁。</p><hr><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>它的使用可以替代synchronized：在原来使用synchronized(this)的地方换成reentrantLock.lock()，然后记得最后要reentrantLock.unlock()。同时要注意把lock()写在try里面，unlock()写在finally里面。以避免出现异常而无法正常释放锁。</p><p>ReentrantLock有一些比synchronized要强大的地方，比如：</p><ul><li><p>可以尝试锁，自行决定等待锁时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.tryLock(<span class="number">6</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以被打断的加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以实现公平锁：即先到先得，最后来的锁不能马上抢到对象，而是要进入等待队列中排队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock1 = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在某种需求中，比如一个大型的任务，常常需要分配好多子任务去执行，只有当所有子任务都执行完成时候，才能执行主任务，这时候，就可以选择CyclicBarrier了。具体地，一个请求过来之后需要先进行数据库操作+文件操作+计算操作，这三者可以使用三个线程来同步执行，当这三个任务都执行完成后，执行一个渲染页面任务，此时可以在前三者的任务代码中调用CyclicBarrier的await()方法，然后把最后一个任务内容写在CyclicBarrier的Runnable里面。</p><blockquote><p>CyclicBarrier好比一扇门，默认情况下关闭状态，堵住了线程执行的道路，直到所有线程都就位，门才打开，让所有线程一起通过。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run application&quot;</span>);<span class="comment">//主任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;<span class="comment">//子任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            barrier.await();<span class="comment">//子任务中await一次CyclicBarrier</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(runnable,<span class="string">&quot;Thread&quot;</span>+i).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="读写锁ReadWriteLock"><a href="#读写锁ReadWriteLock" class="headerlink" title="读写锁ReadWriteLock"></a>读写锁ReadWriteLock</h2><p>对于一些读操作频繁而写操作不频繁的业务来说有巨大的性能提升。由ReentrantReadWriteLock类提供。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    Lock readLock = readWriteLock.readLock();</span><br><span class="line">    Lock writeLock = readWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;read(readLock)).start();<span class="comment">//这里传入readLock就会迅速执行完毕，若传入lock则会有漫长的等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span>  Thread(()-&gt;write(writeLock)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h2><p>可以用来【限流】。</p><p>无论有多少个线程活跃着，能运行的（获取到锁）只有permits限定的这么多个。每次acquire就会使得permits减一，每次release就会加一。</p><p>可以形象地理解成车道和收费站的关系。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 多线程 </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发2</title>
      <link href="archives/d904524b.html"/>
      <url>archives/d904524b.html</url>
      
        <content type="html"><![CDATA[<p>摘要：volatile，单例模式，synchronized优化，CAS</p><a id="more"></a><h2 id="volatile作用："><a href="#volatile作用：" class="headerlink" title="volatile作用："></a>volatile作用：</h2><ul><li>保证线程可见性 </li><li>禁止指令重排序</li></ul><p>单例模式，懒汉生成法，要保证线程安全【双重检查】：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> test INSTANCE; <span class="comment">//要加volatile，原因解释在下方</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE==<span class="keyword">null</span>)&#123;<span class="comment">//判断的时候先不加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (test.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE==<span class="keyword">null</span>)&#123;<span class="comment">//上一次判断后，要加锁，在new之前，看看在此期间是否有被别的线程抢占了锁并已经new出来了对象</span></span><br><span class="line">                    INSTANCE=<span class="keyword">new</span> test();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;<span class="comment">//返回单例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someFunctions</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;some functions.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(test.getInstance().hashcode());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：双重检查写法的单例模式是否要加volatile？"><a href="#问题：双重检查写法的单例模式是否要加volatile？" class="headerlink" title="问题：双重检查写法的单例模式是否要加volatile？"></a>问题：双重检查写法的单例模式是否要加volatile？</h2><p>答案：<strong>要的</strong>。</p><p>INSTANCE=new test();这一句话在JVM中有三个步骤：1. 申请内存（带有默认值）。2. 设置成员的值。3. 让引用指向内存的地址。</p><p>在不加volatile的情况下，上述的第2第3个步骤可能会进行指令重排，也就是：申请内存-&gt;引用指向内存地址-&gt;设置成员的值。</p><p>在超高并发的场景下，线程A在new的过程中申请了带有默认值的内存，并把引用指向了该地址，还没来得及修改成员的值。此时线程B查看INSTANCE不为空，直接返回该单例并使用。在这种情况下，线程B拿到的成员的值是不对的，因为线程A还没有正确地初始化它。</p><p>加了volatile之后指令重排序不被允许，那么线程A在new的过程中就可以保证成员的值被正确初始化后才赋值给引用，就不会出现上述的问题了。</p><p><strong>结论：双重检查写法的单例模式要加volatile</strong>。</p><hr><h2 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h2><p>锁的细化，只加在需要锁的那部分代码。</p><p>如果synchronized对某个对象进行锁，那么建议那个对象添加修饰词final，以避免出现对象引用变化的情况。</p><p>不要用String类型来作为锁的对象。</p><hr><h2 id="CAS-compare-and-swap-set"><a href="#CAS-compare-and-swap-set" class="headerlink" title="CAS compare and swap/set"></a>CAS compare and swap/set</h2><p>无锁优化 或者叫 <strong>乐观锁</strong>。</p><p>AtomicInteger可以实现。</p><p><strong>ABA问题</strong>解决：加版本号。修改一次版本号加一，检查的时候包括值本身和版本号。AtomicStampedReference类可以做到。</p><p>其实对于基本数据类型并没有问题，对于引用类型需要留意。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 多线程 </tag>
            
            <tag> volatile </tag>
            
            <tag> synchronized </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发1</title>
      <link href="archives/400d03f1.html"/>
      <url>archives/400d03f1.html</url>
      
        <content type="html"><![CDATA[<p>摘要：启动线程方法，yield，join，线程状态，synchronized底层，CAS</p><a id="more"></a><h2 id="启动线程的3种方法："><a href="#启动线程的3种方法：" class="headerlink" title="启动线程的3种方法："></a>启动线程的3种方法：</h2><ul><li><p>继承Thread并重写run方法</p></li><li><p>实现Runnable接口并重写run方法</p></li><li><p>通过lambda方法来启动   或者   通过线程池Executor.newCachedThread来进行启动线程</p></li></ul><hr><h2 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程 线程 协程"></a>进程 线程 协程</h2><p>线程是进程的最小执行单元</p><p>一个程序里不同的执行路径可以理解为线程</p><hr><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>让出CPU并进入等待状态</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>t1线程里面调用t2.join()，会去执行t2，搞定之后回来继续执行t1</p><hr><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://user-images.githubusercontent.com/17522733/97427594-14dd7f00-1915-11eb-90a6-17b69d8f4f34.png" alt="多线程状态转移图 (1)"></p><p>不要尝试去手动关闭线程，要让其正常结束</p><p>出现异常的时候正常会释放锁，所以需要格外小心，以免一个线程的脏数据在异常后被另一个线程读到</p><hr><h2 id="synchronized的底层实现："><a href="#synchronized的底层实现：" class="headerlink" title="synchronized的底层实现："></a>synchronized的底层实现：</h2><p>JDK早期的时候是重量级的，需要调用OS的方法</p><p>后来做了改进，<strong>锁升级</strong>的概念：</p><ul><li><p>如果当前只有一个线程想要对某个对象占用锁的话，直接在该对象的头部<strong>markword</strong>记录这个线程的ID，此为偏向锁。若同一把锁重入，就可以很方便地检查markword中记录的ID是否和自己一样，一样的话就直接执行，很快速方便。</p></li><li><p>如果有线程争用，则升级为<strong>自旋锁</strong>，等待的线程会反复查询该对象的锁是否已经被释放。</p></li><li><p>在自旋查询10次以后，升级为<strong>重量级锁</strong>，调用OS的方法，进入到等待队列中。这个线程就进入了等待状态，不占用CPU资源。</p></li></ul><hr><h2 id="什么时候使用自旋锁更好？"><a href="#什么时候使用自旋锁更好？" class="headerlink" title="什么时候使用自旋锁更好？"></a>什么时候使用自旋锁更好？</h2><p>自旋锁不会调用OS的方法，一直处于用户态而不进入内核态，但会占用CPU的资源</p><p>因此对于执行时间长的任务建议使用OS锁，也就是synchronized。</p><p>对于执行时间短的任务可以使用自旋锁，但是需要保证等待的任务数不能过多，否则会CPU会受不了。</p><p><strong>总结：</strong></p><ul><li>加锁的代码执行时间长，线程数多，使用重量级锁synchronized。  </li><li>加锁的代码任务执行时间短，线程数少，使用自旋锁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 多线程 </tag>
            
            <tag> synchronized </tag>
            
            <tag> CAS </tag>
            
            <tag> 线程状态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用命令</title>
      <link href="archives/6fc55794.html"/>
      <url>archives/6fc55794.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="windows下查看端口占用、杀死进程"><a href="#windows下查看端口占用、杀死进程" class="headerlink" title="windows下查看端口占用、杀死进程"></a>windows下查看端口占用、杀死进程</h2><p>查看占用端口号7900的进程：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|findstr <span class="string">&quot;7900&quot;</span></span><br></pre></td></tr></table></figure><p>得到PID号后（如6764），根据该PID杀死进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /f /pid  6764</span><br></pre></td></tr></table></figure><h2 id="Linux-CentOS下安装docker"><a href="#Linux-CentOS下安装docker" class="headerlink" title="Linux/CentOS下安装docker"></a>Linux/CentOS下安装docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>安装完有提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If you would like to use Docker as a non-root user, you should now consider</span><br><span class="line">adding your user to the &quot;docker&quot; group with something like:</span><br><span class="line"></span><br><span class="line">  sudo usermod -aG docker your-user</span><br><span class="line"></span><br><span class="line">Remember that you will have to log out and back in for this to take effect!</span><br></pre></td></tr></table></figure><p>需要先启动docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker ps -as          #查看当前的所有container</span><br><span class="line"></span><br><span class="line">docker start $PID     #启动一个container</span><br><span class="line"></span><br><span class="line">docker attach $PID   #进入一个container</span><br><span class="line"></span><br><span class="line">sudo docker exec -ti [CONTAINER-ID] bash      #另一种进入container的方式</span><br></pre></td></tr></table></figure><p>使用<code>docker exec</code>命令之后如果想要退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + c + ctrl + p + ctrl + q</span><br></pre></td></tr></table></figure><h2 id="使用SSH方式登录远程服务器访问某个端口并在浏览器查看访问结果"><a href="#使用SSH方式登录远程服务器访问某个端口并在浏览器查看访问结果" class="headerlink" title="使用SSH方式登录远程服务器访问某个端口并在浏览器查看访问结果"></a>使用SSH方式登录远程服务器访问某个端口并在浏览器查看访问结果</h2><p>对于某些dashboard等应用，其后端运行在远程的linux服务器上（如阿里云），这些服务器并没有图形化界面，所以我们需要使用本地的浏览器来访问远程的对应端口。需要进行以下配置：</p><ol><li><p>开启远程服务器的防火墙端口：</p><ol><li><p>安装防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install firewalld</span><br></pre></td></tr></table></figure></li><li><p>启动防火墙并开启其自动启动功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start firewalld</span><br><span class="line">sudo systemctl enable firewalld</span><br><span class="line">sudo systemctl status firewalld</span><br></pre></td></tr></table></figure></li><li><p>开启某个端口，比如8080，并刷新一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></li></ol></li><li><p>xshell连接设置相关规则：</p><p><img src="https://user-images.githubusercontent.com/17522733/95740659-3a1f8b80-0c8d-11eb-8dd2-17fcfd1c7597.png" alt="image-20201012131636338"></p><p>使用xshell建立隧道，把访问本地的端口变成访问服务器上的端口：右键自己的会话-&gt;属性-&gt;连接-&gt;ssh-&gt;隧道，添加规则。</p></li><li><p>访问本地服务器localhost:8080即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客的备份</title>
      <link href="archives/46eab5cb.html"/>
      <url>archives/46eab5cb.html</url>
      
        <content type="html"><![CDATA[<p>相关的hexo仓库备份策略，用于多地同时编辑及备份</p><a id="more"></a><p>新建博文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hexo n &quot;name_of_file&quot;</span><br></pre></td></tr></table></figure><p>清空数据库旧记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hexo clean</span><br></pre></td></tr></table></figure><p>生成新记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hexo g</span><br></pre></td></tr></table></figure><p>把生成的页面推送上去GitHub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hexo d</span><br></pre></td></tr></table></figure><hr><p>把源文件也推送上去GitHub：</p><p>在根目录下进行Git初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><strong>创建源文件分支，命名为blog，用来存放源码【重点】</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b blog</span><br></pre></td></tr></table></figure><p>文件添加 并 提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add.</span><br><span class="line">git commit -m &#x27;backup&#x27;</span><br></pre></td></tr></table></figure><p>添加远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:UserName/UserName.github.io.git</span><br></pre></td></tr></table></figure><p>push到blog分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin blog</span><br></pre></td></tr></table></figure><p>相关连接：</p><ul><li><a href="https://www.yansheng.xyz/article/b4e9a9a2.html">参考链接</a>1</li><li><a href="https://blog.csdn.net/zk673820543/article/details/52698760">参考链接</a>2</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo相关有用链接</title>
      <link href="archives/18c3ed78.html"/>
      <url>archives/18c3ed78.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://refined-x.com/2017/07/10/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/">Hexo自定义页面的方法</a></p><p><a href="https://tding.top/archives/9a232bbe.html">yilia主题下Categories分类构建</a></p><p><a href="https://rhirufxmbcyj.gitlab.io/2018/10/11/%E8%AE%A9%E7%99%BE%E5%BA%A6%E5%92%8C%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95%E8%87%AA%E5%B7%B1%E7%9A%84GitLab%E5%8D%9A%E5%AE%A2/">验证站点并添加sitemap</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="archives/a14eb637.html"/>
      <url>archives/a14eb637.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-Benefit-of-generic"><a href="#1-Benefit-of-generic" class="headerlink" title="1. Benefit of generic"></a>1. Benefit of generic</h4><p>The benefit of using generic along with container is that we can specify what is stored in the<br>container to avoid confusion of data type.</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;APHero&gt; heros = <span class="keyword">new</span> ArrayList&lt;APHero&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只有APHero可以放进去</span></span><br><span class="line">        heros.add(<span class="keyword">new</span> APHero());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ADHero甚至放不进去</span></span><br><span class="line">        <span class="comment">//heros.add(new ADHero());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取的时候也不需要进行转型，因为取出来一定是APHero</span></span><br><span class="line">        APHero apHero =  heros.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can also specify the &lt;Type&gt; and store its sub-class into the container.</p><blockquote><p>对象类型可以是泛型类型的子类，比如说在泛型集合声明时使用父类作为参数，那么在这个集合中可以放进去子类的实例。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只有作为Hero的子类可以放进去</span></span><br><span class="line">        heros.add(<span class="keyword">new</span> APHero());</span><br><span class="line">        heros.add(<span class="keyword">new</span> ADHero());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//和Hero无关的类型Item还是放不进去</span></span><br><span class="line">        <span class="comment">//heros.add(new Item());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Generic-Stack"><a href="#2-Generic-Stack" class="headerlink" title="2. Generic Stack"></a>2. Generic Stack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    LinkedList&lt;T&gt; heros = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heros.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heros.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T h)</span></span>&#123;</span><br><span class="line">        heros.addLast(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Above is a generic stack which can store different types of objects. For exemples:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyStack&lt;Hero&gt;heroStack = <span class="keyword">new</span> MyStack&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">    heroStack.push(<span class="keyword">new</span> Hero(<span class="string">&quot;h&quot;</span>+i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">    Hero temp = heroStack.pull();</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-extends"><a href="#3-extends" class="headerlink" title="3. ?extends"></a>3. ?extends</h4><blockquote><p>ArrayList heroList&lt;? extends Hero&gt; 表示这是一个Hero泛型或者其子类泛型</p></blockquote><p>Now that it can store Hero and its sub-class, we can definitely take objects out from the container and cast it into Hero.<br>Therefore, we <strong>CAN</strong> take objects out but <strong>CAN NOT</strong> put objects in. Because if you put an object in, it can be other sub-class<br>of the &lt;?extends Type&gt; and thus cause confusion.</p><center><p><img src="https://user-images.githubusercontent.com/17522733/68239514-66597380-000b-11ea-8e8f-5049091dd7b4.png" alt="837"></p></center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> ArrayList&lt;APHero&gt;();</span><br><span class="line">        apHeroList.add(<span class="keyword">new</span> APHero());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//? extends Hero 表示这是一个Hero泛型的子类泛型</span></span><br><span class="line">        ArrayList&lt;? extends Hero&gt; heroList = apHeroList;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Hero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以使APHero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以使ADHero</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的</span></span><br><span class="line">        Hero h= heroList.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//但是，不能往里面放东西</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> ADHero()); <span class="comment">//编译错误，因为heroList的泛型 有可能是APHero</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-super"><a href="#4-super" class="headerlink" title="4. ?super"></a>4. ?super</h4><blockquote><p>ArrayList heroList&lt;? super Hero&gt; 表示这是一个Hero泛型或者其父类泛型</p></blockquote><p>We can put Hero and sub-class of Hero into the container but we <strong>CAN NOT</strong> take objects out because we have no idea<br>what we may take out. For exemples, we cannot take out an <code>Object</code> and cast it into Hero.</p><p>可以 父类=子类，不可以 子类=父类。因此不能取出来，不然没地儿放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//? super Hero 表示 heroList的泛型是Hero或者其父类泛型</span></span><br><span class="line">        ArrayList&lt;? <span class="keyword">super</span> Hero&gt; heroList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Hero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Object</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//所以就可以插入Hero</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> Hero());</span><br><span class="line">        <span class="comment">//也可以插入Hero的子类</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> APHero());</span><br><span class="line">        heroList.add(<span class="keyword">new</span> ADHero());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//但是，不能从里面取数据出来,因为其泛型可能是Object,而Object是强转Hero会失败</span></span><br><span class="line">        Hero h= heroList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a>5. Conclusion</h4><blockquote><p>如果希望只取出，不插入，就使用? extends Hero</p></blockquote><blockquote><p>如果希望只插入，不取出，就使用? super Hero</p></blockquote><h4 id="5-Casting-between-generic"><a href="#5-Casting-between-generic" class="headerlink" title="5. Casting between generic"></a>5. Casting between generic</h4><p>Conclusion: super class generic cannot cast to sub class generic nor vice versa.</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="archives/735e5788.html"/>
      <url>archives/735e5788.html</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h2><p><img src="https://user-images.githubusercontent.com/17522733/98710150-90aee100-2383-11eb-854f-bb4791b5e55e.gif" alt="quickSort"></p><a id="more"></a><h2 id="基本思想：挖坑填数-分治法"><a href="#基本思想：挖坑填数-分治法" class="headerlink" title="基本思想：挖坑填数 + 分治法"></a>基本思想：<strong>挖坑填数 + 分治法</strong></h2><ol><li>从序列中取出一个数作为基准数</li><li>分区过程：将比这个数大的数全部放到它的右边，小于或等于它的数全部放到它的左边</li><li>递归地对左右子序列尽心步骤2，直到各区间只有一个数</li></ol><hr><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>我们这里有初始数组如下</p><table><thead><tr><th align="center">i=0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">j=7</th></tr></thead><tbody><tr><td align="center">(49)</td><td align="center">38</td><td align="center">65</td><td align="center">97</td><td align="center">76</td><td align="center">13</td><td align="center">27</td><td align="center">49</td></tr></tbody></table><p>对于这个算法，我们需要两个变量<code>i</code>和<code>j</code>分别代表数组的两端，这两个变量将会分别往中间靠拢。</p><p>约定取当前区间的第一个元素为<code>index</code>作为参考，即<code>index = arr[i] = arr[0] = 49</code>。</p><p>这时<code>i=0</code>的地方就已经挖了一个坑。我们从数组的右端开始往左遍历<code>j</code>，找出比<code>index</code>小的数<code>arr[j]</code>，填到<code>arr[i]</code>即 <code>arr[0]</code>的位置；</p><p>显然当<code>j=6</code>时满足<code>arr[6]&lt;index</code>，所以按照上一行的解释<code>arr[0] = arr[i] = arr[j] = arr[6] = 27</code>，并且<code>i++</code>，数组变成：</p><table><thead><tr><th align="center">0</th><th align="center">i=1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">j=6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">27</td><td align="center">38</td><td align="center">65</td><td align="center">97</td><td align="center">76</td><td align="center">13</td><td align="center">(27)</td><td align="center">49</td></tr></tbody></table><p>这时<code>j=6</code>的地方就挖了一个坑。我们从数组的左端开始往右遍历<code>i</code>，找出比<code>index</code>大的数<code>arr[i]</code>，填到<code>arr[j]</code>即<code>arr[6]</code>的位置；</p><p>显然当<code>i=2</code>的时候满足<code>arr[2]&gt;index</code>，所以按照上一行的解释<code>arr[6] = arr[j] = arr[i] = arr[2] = 65</code>，并且<code>j--</code>，数组变成：</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">i=2</th><th align="center">3</th><th align="center">4</th><th align="center">j=5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">27</td><td align="center">38</td><td align="center">(65)</td><td align="center">97</td><td align="center">76</td><td align="center">13</td><td align="center">65</td><td align="center">49</td></tr></tbody></table><p>这是<code>i=2</code>的地方就被挖出一个坑。</p><p>再重复上面的步骤，<strong>先从后往前找，再从前往后找</strong>。</p><p>从<code>j</code>开始往前找，当<code>j=5</code>时，符合条件，将<code>arr[5]</code>挖出一个坑，<code>arr[i] = arr[2]</code>的坑被填上，并且<code>i++</code>，数组变成：。</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">i=3</th><th align="center">4</th><th align="center">j=5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">27</td><td align="center">38</td><td align="center">13</td><td align="center">97</td><td align="center">76</td><td align="center">(13)</td><td align="center">65</td><td align="center">49</td></tr></tbody></table><p>从<code>i</code>开始往后找，当<code>i=3</code>时，符合条件，将<code>arr[3]</code>挖出一个坑，<code>arr[j] = arr[5]</code>的坑被填上，并且<code>j--</code>，数组变成：。</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">i=3</th><th align="center">j=4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">27</td><td align="center">38</td><td align="center">13</td><td align="center">(97)</td><td align="center">76</td><td align="center">97</td><td align="center">65</td><td align="center">49</td></tr></tbody></table><p>从<code>j</code>开始往前找，此时<code>i==3,j==4</code>，由于要保持<code>i&lt;j</code>这个条件，所以无法再继续找到合适的元素。</p><p>这时只需要把<code>index</code>填回去<code>arr[i]</code>这个坑即可：</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">27</td><td align="center">38</td><td align="center">13</td><td align="center">index=49</td><td align="center">76</td><td align="center">97</td><td align="center">65</td><td align="center">49</td></tr></tbody></table><p>通过上面这一轮可以看出，<code>arr[3]</code>前面的数字都小于它，<code>arr[3]</code>后面的数字都大于它。</p><p>只需要对<code>arr[0...2]</code>和<code>arr[4....7]</code>这两个子区间重复上述步骤即可。</p><hr><h2 id="对挖坑填数进行总结"><a href="#对挖坑填数进行总结" class="headerlink" title="对挖坑填数进行总结"></a>对挖坑填数进行总结</h2><p>1．i = L; j = R; 将基准数挖出形成第一个坑 a[i]。</p><p>2．j– 由后向前找比它小的数，找到后挖出此数填前一个坑 a[i] 中。</p><p>3．i++ 由前向后找比它大的数，找到后也挖出此数填到前一个坑 a[j] 中。</p><p>4．再重复执行 2，3 二步，直到 i==j，将基准数填入 a[i] 中。</p><h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low, j = high;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];        <span class="comment">//挖坑，取当前区间的第一个数为基准</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= temp) &#123;</span><br><span class="line">                j--;            <span class="comment">//j-- 由后向前找比它小的数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;j)&#123;</span><br><span class="line">                a[i] = a[j];        <span class="comment">//找到后挖出此数填前一个坑 a[i] 中</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt; temp) &#123;</span><br><span class="line">                i++;            <span class="comment">//i++ 由前向后找比它大的数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;j)&#123;</span><br><span class="line">                a[j] = a[i];        <span class="comment">//找到后也挖出此数填到前一个坑 a[j] 中</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = temp;</span><br><span class="line">        sort(a, low, i-<span class="number">1</span>);</span><br><span class="line">        sort(a, i+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = &#123; <span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span> &#125;;</span><br><span class="line">        quickSort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之IO</title>
      <link href="archives/6a7238df.html"/>
      <url>archives/6a7238df.html</url>
      
        <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h4 id="1-File"><a href="#1-File" class="headerlink" title="1.File"></a>1.File</h4><p>Some basic manipulations about <code>File</code>:</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">File test1 = <span class="keyword">new</span> File(<span class="string">&quot;c:\\WINDOWS\\&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;path: &quot;</span> + test1.getAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">&quot;existence: &quot;</span> + test1.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;directory: &quot;</span> + test1.isDirectory());</span><br><span class="line">System.out.println(<span class="string">&quot;file: &quot;</span> + test1.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;length: &quot;</span> + test1.length());</span><br><span class="line">System.out.println(<span class="string">&quot;last modify time: &quot;</span> + <span class="keyword">new</span> Date((<span class="keyword">long</span>)test1.lastModified()));</span><br><span class="line">test1.renameTo(<span class="keyword">new</span> File(<span class="string">&quot;texe.exe&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;path: &quot;</span> + test1.getAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">&quot;father: &quot;</span> + test1.getParentFile());</span><br></pre></td></tr></table></figure><h4 id="2-Find-specific-file-in-directory"><a href="#2-Find-specific-file-in-directory" class="headerlink" title="2.Find specific file in directory"></a>2.Find specific file in directory</h4><p>Find the maximum and minimum size file in a directory and print their sizes &amp; names</p><ul><li>no sub-directory:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(test1.list()));</span><br><span class="line">File[]fs= test1.listFiles();</span><br><span class="line"><span class="keyword">long</span> maxValue = Integer.MIN_VALUE;</span><br><span class="line">File maxName = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">long</span> minValue = Integer.MAX_VALUE;</span><br><span class="line">File minName = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span>(File f: fs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f.length()&gt;maxValue &amp;&amp; f.length()!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        maxValue = f.length();</span><br><span class="line">        maxName = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f.length()&lt;minValue &amp;&amp; f.length()!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        minValue = f.length();</span><br><span class="line">        minName = f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> maxName != <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;Max: &quot;</span> + maxName.getAbsolutePath() + <span class="string">&quot; &quot;</span> + maxValue);</span><br><span class="line"><span class="keyword">assert</span> minName != <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;Min: &quot;</span> + minName.getAbsolutePath() + <span class="string">&quot; &quot;</span> + minValue);</span><br></pre></td></tr></table></figure></li><li>sub-directory:<br>For this, we do it in a recursive way:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> maxValue1 = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File maxName1 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> minValue1 = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File minName1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">            File[] temp = file.listFiles();</span><br><span class="line">            <span class="keyword">if</span>(temp!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">for</span>(File f:temp)</span><br><span class="line">                find(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.length()&gt;maxValue1 &amp;&amp; file.length()!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                maxValue1 = file.length();</span><br><span class="line">                maxName1 = file;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(file.length()&lt;minValue1 &amp;&amp; file.length()!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                minValue1 = file.length();</span><br><span class="line">                minName1 = file;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">File test1 = <span class="keyword">new</span> File(<span class="string">&quot;c:\\WINDOWS\\&quot;</span>);</span><br><span class="line">find(test1);</span><br><span class="line">System.out.println(<span class="string">&quot;Max: &quot;</span> + maxName1.getAbsolutePath() + <span class="string">&quot; &quot;</span> + maxValue1);</span><br><span class="line">System.out.println(<span class="string">&quot;Min: &quot;</span> + minName1.getAbsolutePath() + <span class="string">&quot; &quot;</span> + minValue1);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Byte-Stream"><a href="#3-Byte-Stream" class="headerlink" title="3.Byte Stream"></a>3.Byte Stream</h4><p>Pay attention:<br>OutputStream是字节输出流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。<br>FileOutputStream 是OutputStream子类，以FileOutputStream 为例向文件写出数据</p><p>注: 如果文件d:/lol2.txt不存在，写出操作会自动创建该文件。<br>但是如果是文件 d:/xyz/lol2.txt，而目录xyz又不存在，会抛出异常<br>那么怎么自动创建xyz目录？:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/xyz/abc/def/lol2.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//因为默认情况下，文件系统中不存在 d:\xyz\abc\def，所以输出会失败</span></span><br><span class="line">            <span class="comment">//首先获取文件所在的目录</span></span><br><span class="line">            File dir = f.getParentFile();</span><br><span class="line">            <span class="comment">//如果该目录不存在，则创建该目录</span></span><br><span class="line">            <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line"><span class="comment">//              dir.mkdir(); //使用mkdir会抛出异常，因为该目录的父目录也不存在</span></span><br><span class="line">                dir.mkdirs(); <span class="comment">//使用mkdirs则会把不存在的目录都创建好</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span> data[] = &#123; <span class="number">88</span>, <span class="number">89</span> &#125;;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">            fos.write(data);</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Tear-down-file-into-several-parts"><a href="#4-Tear-down-file-into-several-parts" class="headerlink" title="4.Tear down file into several parts"></a>4.Tear down file into several parts</h4><p>Essence: read the file from hard disk into memory then divide it into whatever we want.</p><h4 id="5-Close-Stream-in-the-right-way"><a href="#5-Close-Stream-in-the-right-way" class="headerlink" title="5.Close Stream in the right way"></a>5.Close Stream in the right way</h4><ul><li>primitive way:<br>we close all the FileInputStream/FileOutputStream in the <code>finally</code> block to avoid forgetting to close them in <code>try</code>/<code>catch</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(File f)</span></span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;<span class="comment">//make sure that it is here insdead of in the &#x27;try&#x27; block</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(f);<span class="comment">//initialize here</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">            fis.read(data);<span class="comment">//read data like this</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">byte</span> b:data)</span><br><span class="line">                System.out.println(b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; <span class="comment">//need a &#x27;try&#x27; block to enable the close manipulation</span></span><br><span class="line">                    fis.close(); <span class="comment">//we close the FileInputStream here</span></span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li>avanced way(try-with-resources):<br>we do everything in the <code>try(...)</code> block, so called <strong>AutoCloseable</strong> :<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read_avanced</span><span class="params">(File f)</span></span>&#123;</span><br><span class="line">        <span class="comment">//把流定义在try()里,try,catch或者finally结束的时候，会自动关闭</span></span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fis = <span class="keyword">new</span> FileInputStream(f))&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">byte</span> b:data)</span><br><span class="line">                System.out.println(b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…."></a>未完待续….</h4>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之Lambda表达式</title>
      <link href="archives/34f2cda5.html"/>
      <url>archives/34f2cda5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>整章围绕集合筛选来做</p><a id="more"></a><h4 id="1-Find-out-heros-that-satisfy-requirements-in-a-common-way"><a href="#1-Find-out-heros-that-satisfy-requirements-in-a-common-way" class="headerlink" title="1. Find out heros that satisfy requirements in a common way"></a>1. Find out heros that satisfy requirements in a common way</h4><p>First of all we have basic Hero class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name =name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化name,hp,damage的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name,<span class="keyword">float</span> hp, <span class="keyword">int</span> damage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name =name;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">        <span class="keyword">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;, hp=&quot;</span> + hp + <span class="string">&quot;, damage=&quot;</span> + damage + <span class="string">&quot;]\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Then we have a common function to filter specific Heros:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;Hero&gt; heros)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Hero h:heros)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h.damage&lt;<span class="number">50</span> &amp;&amp; h.hp&gt;<span class="number">100</span>)&#123;</span><br><span class="line">                System.out.println(h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;Hero&gt; heros)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Hero h:heros)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h.damage&lt;<span class="number">50</span> &amp;&amp; h.hp&gt;<span class="number">100</span>)&#123;</span><br><span class="line">                System.out.println(h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;h&quot;</span>+i,r.nextInt(<span class="number">1000</span>),r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        filter(heros);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Anonyme-function"><a href="#2-Anonyme-function" class="headerlink" title="2.Anonyme function:"></a>2.Anonyme function:</h4><blockquote><p>首先准备一个接口HeroChecker，提供一个test(Hero)方法<br>然后通过匿名类的方式，实现这个接口</p></blockquote><p>So first we construct an interface:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HeroChecker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">herochecker</span><span class="params">(Hero h)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And then we need to reconstruct a function of filter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter_anonyme</span><span class="params">(List&lt;Hero&gt;heros, HeroChecker heroChecker)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Hero h : heros)&#123;</span><br><span class="line">            <span class="keyword">if</span>(heroChecker.herochecker(h))&#123;</span><br><span class="line">                System.out.println(h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>In the main function we use the anonyme function like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HeroChecker heroChecker = <span class="keyword">new</span> HeroChecker() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">herochecker</span><span class="params">(Hero h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h.damage &lt; <span class="number">50</span> &amp;&amp; h.hp &gt; <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">filter_anonyme(heros,heroChecker);</span><br></pre></td></tr></table></figure><h4 id="3-lambda-way"><a href="#3-lambda-way" class="headerlink" title="3. lambda way"></a>3. lambda way</h4><p>Instead of (1)constructing an interface &amp; (2)implementing the details of the instance of the interface in the main function, (like above), we distill the essence of the HeroChecker(instance of the interface) and represent it as a single line, and as a parameter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        HeroChecker heroChecker = <span class="keyword">new</span> HeroChecker() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">herochecker</span><span class="params">(Hero h)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> h.damage &lt; <span class="number">50</span> &amp;&amp; h.hp &gt; <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//        filter_anonyme(heros,heroChecker); //old way as aboved</span></span><br><span class="line">        filter_anonyme(heros , h-&gt;h.damage&lt;<span class="number">50</span> &amp;&amp; h.hp&gt;<span class="number">100</span>);<span class="comment">//lambda way!!!</span></span><br></pre></td></tr></table></figure><p>Then we will use another exemple to describe how an anonyme class becomes a lambda line:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名类</span></span><br><span class="line">        Comparator&lt;Hero&gt; c = <span class="keyword">new</span> Comparator&lt;Hero&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Hero h1, Hero h2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> h1.hp&gt;=h2.hp?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//equals</span></span><br><span class="line">       c = (Hero h1, Hero h2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> h1.hp&gt;=h2.hp?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//equals</span></span><br><span class="line">       c = (Hero h1, Hero h2) -&gt; h1.hp&gt;h2.hp?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//equals</span></span><br><span class="line">       c = (h1,h2) -&gt; h1.hp&gt;h2.hp?<span class="number">1</span>:-<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>Voila!</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="archives/8fe47ff4.html"/>
      <url>archives/8fe47ff4.html</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h4 id="1-增删改"><a href="#1-增删改" class="headerlink" title="1.增删改"></a>1.增删改</h4> <a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String sql)</span></span>&#123;</span><br><span class="line">    <span class="comment">//To import relevant .jar</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Use this kind of try block to enable automatic shut down of connection after manipulation</span></span><br><span class="line">    <span class="keyword">try</span>(Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test1?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">            <span class="string">&quot;root&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        Statement s = c.createStatement())</span><br><span class="line">        &#123;</span><br><span class="line">          s.execute(sql);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//Samples:</span></span><br><span class="line">    String sql = <span class="string">&quot;update hero set name = &#x27;change2&#x27; where id = 12&quot;</span>;</span><br><span class="line">    String sql1 = <span class="string">&quot;insert into hero values(null,&#x27;hero1&#x27;,200,100)&quot;</span></span><br><span class="line">    execute(sql);</span><br><span class="line">    execute(sql1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-查"><a href="#2-查" class="headerlink" title="2. 查"></a>2. 查</h4><p>Here we use ResultSet to get the returned result.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeQuery</span><span class="params">(String sql)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>(Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test1?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">            <span class="string">&quot;root&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        Statement s = c.createStatement())</span><br><span class="line">        &#123;</span><br><span class="line">          ResultSet resultSet = s.executeQuery(sql);</span><br><span class="line">          <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">              <span class="keyword">int</span> id = resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">              String name = resultSet.getString(<span class="number">2</span>);</span><br><span class="line">              <span class="keyword">float</span> hp = resultSet.getFloat(<span class="string">&quot;hp&quot;</span>);</span><br><span class="line">              <span class="keyword">int</span> damage = resultSet.getInt(<span class="number">4</span>);</span><br><span class="line">              System.out.printf(<span class="string">&quot;%d\t%s\t%f\t%d%n&quot;</span>, id, name, hp, damage);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//Samples:</span></span><br><span class="line">      String sql = <span class="string">&quot;select * from hero&quot;</span>;</span><br><span class="line">      executeQuery(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-list-data-of-limit-amount"><a href="#3-list-data-of-limit-amount" class="headerlink" title="3. list data of limit amount"></a>3. list data of limit amount</h4><p>This can avoid wasting out all the memory the JVM. And facilitate the query speed by reducing the amount of data required, at the other hand, it is useful for inquerying data in a web page because each page can only contain limit amount of data presented.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>(Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test1?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">            <span class="string">&quot;root&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        Statement s = c.createStatement()) &#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from hero limit &quot;</span> + start + <span class="string">&#x27;,&#x27;</span>+ count;</span><br><span class="line">        ResultSet resultSet = s.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="keyword">int</span> id = resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String name = resultSet.getString(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">float</span> hp = resultSet.getFloat(<span class="string">&quot;hp&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> damage = resultSet.getInt(<span class="number">4</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%s\t%f\t%d%n&quot;</span>, id, name, hp, damage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      list(<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-PreparedStatement"><a href="#4-PreparedStatement" class="headerlink" title="4. PreparedStatement"></a>4. PreparedStatement</h4><p>Advantages:</p><ul><li>Readable, difficult to make mistakes</li><li>Compile only once, therefore faster</li><li>Avoid SQL Injection attack<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String name, <span class="keyword">float</span> hp, <span class="keyword">int</span> damage)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String sql = <span class="string">&quot;insert into hero values(null,?,?,?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test1?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        PreparedStatement ps = c.prepareStatement(sql)) &#123;</span><br><span class="line">        ps.setString(<span class="number">1</span>,name);</span><br><span class="line">        ps.setFloat(<span class="number">2</span>,hp);</span><br><span class="line">        ps.setInt(<span class="number">3</span>,damage);</span><br><span class="line">        ps.execute();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      insert(<span class="string">&quot;insertFunction&quot;</span>,<span class="number">250</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-Difference-between-Statement-execute-and-Statement-executeUpdate"><a href="#5-Difference-between-Statement-execute-and-Statement-executeUpdate" class="headerlink" title="5. Difference between Statement.execute and Statement.executeUpdate"></a>5. Difference between <code>Statement.execute</code> and <code>Statement.executeUpdate</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同1：execute可以执行查询语句, executeUpdate不可以查询</span></span><br><span class="line"><span class="comment">// 然后通过getResultSet，把结果集取出来</span></span><br><span class="line">String sqlSelect = <span class="string">&quot;select * from hero&quot;</span>;</span><br><span class="line">s.execute(sqlSelect);</span><br><span class="line">ResultSet rs = s.getResultSet();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同2:</span></span><br><span class="line"><span class="comment">// execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等</span></span><br><span class="line"><span class="keyword">boolean</span> isSelect = s.execute(sqlSelect);</span><br><span class="line">System.out.println(isSelect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// executeUpdate返回的是int，表示有多少条数据受到了影响</span></span><br><span class="line">String sqlUpdate = <span class="string">&quot;update Hero set hp = 300 where id &lt; 100&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> number = s.executeUpdate(sqlUpdate);</span><br><span class="line">System.out.println(number);</span><br></pre></td></tr></table></figure><h4 id="6-Get-AUTO-INCREMENT-id"><a href="#6-Get-AUTO-INCREMENT-id" class="headerlink" title="6. Get AUTO_INCREMENT id"></a>6. Get AUTO_INCREMENT id</h4><p>We use <code>PreparedStatement</code> and</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    PreparedStatement ps = c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);  <span class="comment">//Pay attention here</span></span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//manipulations...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行插入语句</span></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id</span></span><br><span class="line"><span class="comment">// JDBC通过getGeneratedKeys获取该id</span></span><br><span class="line">ResultSet rs = ps.getGeneratedKeys();</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    System.out.println(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-Commit-and-AutoCommit"><a href="#7-Commit-and-AutoCommit" class="headerlink" title="7. Commit and AutoCommit"></a>7. <code>Commit</code> and <code>AutoCommit</code></h4><p>在事务中的多个操作，要么都成功，要么都失败。<br>通过 c.setAutoCommit(false); 关闭自动提交。<br>使用 c.commit(); 进行手动提交。<br>对于多个数据库操作，若处于同一个事务当中，要么都成功，要么都失败<br>所以，虽然第一条SQL语句是可以执行的，但是第二条SQL语句有错误，其结果就是两条SQL语句都没有被提交。 除非两条SQL语句都是正确的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加血的SQL</span></span><br><span class="line">String sql1 = <span class="string">&quot;update hero set hp = hp +1 where id = 22&quot;</span>;</span><br><span class="line">s.execute(sql1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减血的SQL</span></span><br><span class="line"><span class="comment">// 不小心写错写成了 updata(而非update)</span></span><br><span class="line"></span><br><span class="line">String sql2 = <span class="string">&quot;updata hero set hp = hp -1 where id = 22&quot;</span>;</span><br><span class="line">s.execute(sql2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动提交</span></span><br><span class="line">c.commit();</span><br></pre></td></tr></table></figure><p>For the situation aboved, we cannot commit the two commands because one of them is grammatically wrong.</p><h4 id="8-Object-Relationship-Database-Mapping-ORM"><a href="#8-Object-Relationship-Database-Mapping-ORM" class="headerlink" title="8. Object Relationship Database Mapping (ORM)"></a>8. Object Relationship Database Mapping (ORM)</h4><p>对象和关系数据库的映射。<br>简单说，一个对象，对应数据库里的一条记录。<br>这是一种思想，在java代码中创建一个相应的数据类型，然后将其与数据库中的数据关联起来。可以编写诸如get,add,delete,list等函数。在这些函数中搭配PreparedStatement就会很好用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">float</span> hp;</span><br><span class="line">    <span class="keyword">int</span> damage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name,<span class="keyword">float</span> hp,<span class="keyword">int</span> damage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">        <span class="keyword">this</span>.damage = damage;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Hero h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String sql = <span class="string">&quot;insert into hero values(null,?,?,?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test1?characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">         PreparedStatement ps = c.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        ps.setString(<span class="number">1</span>, h.name);</span><br><span class="line">        ps.setFloat(<span class="number">2</span>, h.hp);</span><br><span class="line">        ps.setInt(<span class="number">3</span>, h.damage);</span><br><span class="line">        ps.execute();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    insert(<span class="keyword">new</span> Hero(<span class="string">&quot;TryHero&quot;</span>,<span class="number">200</span>,<span class="number">30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-Data-Access-Object-DAO"><a href="#9-Data-Access-Object-DAO" class="headerlink" title="9. Data Access Object (DAO)"></a>9. Data Access Object (DAO)</h4><p>数据访问对象。<br>实际上就是运用了练习-ORM中的思路，把数据库相关的操作都封装在这个类里面，其他地方看不到JDBC的代码。定义这么一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DAO</span></span>&#123;</span><br><span class="line">    <span class="comment">//增加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Hero hero)</span></span>;</span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Hero hero)</span></span>;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hero <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Hero&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//分页查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Hero&gt; <span class="title">list</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-数据库连接池"><a href="#10-数据库连接池" class="headerlink" title="10. 数据库连接池"></a>10. 数据库连接池</h4><p>待补充……</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常</title>
      <link href="archives/f495a96f.html"/>
      <url>archives/f495a96f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception 异常"></a>Exception 异常</h1><h2 id="1-try-catch"><a href="#1-try-catch" class="headerlink" title="1.try/catch"></a>1.try/catch</h2><p>In order to avoid predictable problems, we are forced to use try/catch for some commands like <code>FileInputStream</code>.</p> <a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        File f= <span class="keyword">new</span> File(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try to open d:/LOL.exe&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            System.out.println(<span class="string">&quot;succeed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;d:/LOL.exe does not existe&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can surely use something like <code>catch(FileNotFoundException|ParseException e)</code> to include several excecptions at a time and in the block we then use something like <code>if(e instanceof FileNotFoundException)&#123;...&#125;</code> to decouple the combined exception. Instead of using several <code>catch</code> after the <code>try</code>.</p><h2 id="2-Usage-of-throws"><a href="#2-Usage-of-throws" class="headerlink" title="2.Usage of throws"></a>2.Usage of <code>throws</code></h2><p><code>throws</code> appears on the declation of a function to showcase a posibility of throwing an exception, which will not necessarily happen. On the contary, when we use <code>throw</code> we are indeed throwing an exception.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method1();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;try to open d:/LOL.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        System.out.println(<span class="string">&quot;succeed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the above case, we throw an exception (if needed) in method2 and in we catch it in method2.</p><h2 id="3-try-catch-finally"><a href="#3-try-catch-finally" class="headerlink" title="3.try/catch/finally"></a>3.try/catch/finally</h2><p>It is NOT good to write codes like this because it will cause ambiguity to what will return in the end:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> return1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> return2();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> return3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">return1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;return 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">return2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;return 2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">return3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;return 3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = method();</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The better way is as follows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    result = return1();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    result = return2();</span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    result = return3();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As for the two exemples aboved, we will go through <code>return1()</code> then <code>return3()</code>, but at the end it will return result of <code>return3()</code> as shown in the better way.</p><h2 id="4-Classification"><a href="#4-Classification" class="headerlink" title="4.Classification"></a>4.Classification</h2><ol><li>CheckedException(e.g. FileNotFoundException,either <em>try/catch</em> either <em>throws exception</em> in declation)</li><li>RuntimeException<br>(e.g. ArithmeticException / ArrayIndexOutOfBoundsException / NullPointerException, Not obligated to use try/catch)</li><li>Error(e.g. OutOfMemoryError)</li></ol><blockquote><p>运行时异常与非运行时异常的区别：</p><ul><li>运行时异常是不可查异常，不需要进行显式的捕捉</li><li>非运行时异常是可查异常，必须进行显式的捕捉，或者抛出</li></ul></blockquote><h2 id="5-throwable"><a href="#5-throwable" class="headerlink" title="5.throwable"></a>5.throwable</h2><p>throwable is the father class of error/exception. It’s possible to throw a <code>throwable</code> in a function but it will also bring ambiguity because we have no idea it will be which kind of problem, so try to be specific about the exception.</p><center>![742](https://user-images.githubusercontent.com/17522733/68072779-867a0000-fd89-11e9-8a6a-2ed4787268ea.png)</center><h2 id="6-Self-defined-exception"><a href="#6-Self-defined-exception" class="headerlink" title="6.Self-defined exception"></a>6.Self-defined exception</h2><p>We can define our personalized exception by inheriting class exception, which may look like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.ls.LSOutput;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.PSource;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hero</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">heroDeadException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123; <span class="comment">//self defined exception</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">heroDeadException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">heroDeadException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> hp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">hero</span><span class="params">(String name, <span class="keyword">int</span> hp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(hero another)</span> <span class="keyword">throws</span> heroDeadException</span>&#123; <span class="comment">//throws exception</span></span><br><span class="line">        <span class="keyword">if</span>(another.hp&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> heroDeadException(another.name+<span class="string">&quot; is dead, no more attack&quot;</span>);<span class="comment">// here we throw out exception</span></span><br><span class="line">        &#125;</span><br><span class="line">        another.hp-=<span class="number">1</span>;</span><br><span class="line">        System.out.println(another.name+<span class="string">&quot; rested hp:&quot;</span>+another.hp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hero a = <span class="keyword">new</span> hero(<span class="string">&quot;a&quot;</span>,<span class="number">99</span>);</span><br><span class="line">        hero b = <span class="keyword">new</span> hero(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                b.attack(a);</span><br><span class="line">                a.attack(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123; <span class="comment">// here we need to catch exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合之Set和List</title>
      <link href="archives/be884c2e.html"/>
      <url>archives/be884c2e.html</url>
      
        <content type="html"><![CDATA[<h1 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h1><h4 id="1-Basic-manipulations-about-a-List"><a href="#1-Basic-manipulations-about-a-List" class="headerlink" title="1.Basic manipulations about a List"></a>1.Basic manipulations about a List</h4><ul><li>add objects at specific positions<a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ArrayList heros = <span class="keyword">new</span> ArrayList();</span><br><span class="line">heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;b&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(heros);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置增加对象</span></span><br><span class="line">Hero specialHero = <span class="keyword">new</span> Hero(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">heros.add(<span class="number">3</span>, specialHero);</span><br><span class="line">System.out.println(heros);</span><br></pre></td></tr></table></figure></li><li>check if contains certain objects <strong>(only when the object is identical)</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//contains</span></span><br><span class="line">         System.out.println(<span class="string">&quot;contain a: &quot;</span>+heros.contains(<span class="keyword">new</span> Hero(<span class="string">&quot;a&quot;</span>)));</span><br><span class="line">         System.out.println(<span class="string">&quot;contain special: &quot;</span>+heros.contains(specialHero));</span><br></pre></td></tr></table></figure></li><li>get objects of specific positions<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="comment">//get</span></span><br><span class="line">    System.out.println(heros.get(<span class="number">1</span>));</span><br><span class="line">    System.out.println(heros.get(heros.size()+<span class="number">1</span>));</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>get positions of specific objects <strong>(need to specify the object wanted, not just the same name)</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="comment">//indexof</span></span><br><span class="line">     System.out.println(<span class="string">&quot;position: &quot;</span>+heros.indexOf(specialHero));</span><br><span class="line">     System.out.println(<span class="string">&quot;position: &quot;</span>+heros.indexOf(<span class="keyword">new</span> Hero(<span class="string">&quot;a&quot;</span>)));</span><br><span class="line"> &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>remove specific objects (or objects of certain positions)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; <span class="comment">//remove</span></span><br><span class="line">    System.out.println(heros);</span><br><span class="line">    heros.remove(<span class="number">2</span>);</span><br><span class="line">    System.out.println(heros);</span><br><span class="line">    heros.remove(specialHero);</span><br><span class="line">    System.out.println(heros);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>replace objects of specific positions<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    System.out.println(heros);</span><br><span class="line">    heros.set(<span class="number">3</span>,specialHero);</span><br><span class="line">    System.out.println(heros);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>cast an <code>ArrayList</code> to an array<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">         <span class="keyword">try</span>&#123;<span class="comment">//wrong casting</span></span><br><span class="line"><span class="comment">//             Hero[] array = (Hero[]) heros.toArray();</span></span><br><span class="line"><span class="comment">//             Hero[] array = (Hero[]) heros.toArray(new Hero[]&#123;&#125;);// wrong as well</span></span><br><span class="line">             System.out.println(array);</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span>&#123;<span class="comment">//right casting</span></span><br><span class="line">             Hero array[] = (Hero[])heros.toArray(<span class="keyword">new</span> Hero[]&#123;&#125;);</span><br><span class="line">             System.out.println(<span class="string">&quot;array: &quot;</span>+array);</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></li><li>add another <code>List</code> into present <code>List</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="comment">//addAll</span></span><br><span class="line">     ArrayList anotherHeros = <span class="keyword">new</span> ArrayList();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         anotherHeros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i*<span class="number">10</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(anotherHeros);</span><br><span class="line">     anotherHeros.addAll(<span class="number">4</span>,heros);</span><br><span class="line">     System.out.println(anotherHeros);</span><br><span class="line"> &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>clear the List<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="comment">//clear</span></span><br><span class="line">    System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line">    heros.clear();</span><br><span class="line">    System.out.println(heros);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-Generic"><a href="#2-Generic" class="headerlink" title="2.Generic"></a>2.Generic</h4><p>If we do this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List heros = <span class="keyword">new</span> ArrayList();</span><br><span class="line">heros.add(Hero(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">heros.add(Hero(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">heros.add(Hero(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">heros.add(Item(<span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure><p>then we may encounter some problems of casting if we forget the corresponding position:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hero h1 = (Hero) heros.get(<span class="number">1</span>);</span><br><span class="line">Hero h2 = (Hero) heros.get(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//wrong if Item is not a sub-class of Hero ↓</span></span><br><span class="line"><span class="comment">//Hero h3 = (Hero) heros.get(3);</span></span><br></pre></td></tr></table></figure><p>so we introduce generic:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Hero&gt; genericheros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">genericheros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;盖伦&quot;</span>));</span><br><span class="line"><span class="comment">//如果不是Hero类型，根本就放不进去</span></span><br><span class="line"><span class="comment">//genericheros.add(new Item(&quot;冰杖&quot;));</span></span><br><span class="line"><span class="comment">//除此之外，还能存放Hero的子类</span></span><br><span class="line">genericheros.add(<span class="keyword">new</span> APHero());</span><br><span class="line"><span class="comment">//并且在取出数据的时候，不需要再进行转型了，因为里面肯定是放的Hero或者其子类</span></span><br><span class="line">Hero h = genericheros.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>Btw, we can neglect the second parameter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Hero&gt; genericheros1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Therefore if we want to construct a List that can <strong>only support certain data type</strong>, we can firstly construct an interface, and let whatever we want to put in the List to <code>implements</code> this interface. Then we construct a List with the type equals the interface:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LOL</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GHero</span> <span class="keyword">implements</span> <span class="title">LOL</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> damage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GHero</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 增加一个初始化name的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GHero</span><span class="params">(String name)</span> </span>&#123;<span class="keyword">this</span>.name = name;&#125;</span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GItem</span> <span class="keyword">implements</span> <span class="title">LOL</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GItem</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个初始化name的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GItem</span><span class="params">(String name)</span></span>&#123;<span class="keyword">this</span>.name = name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">&quot;物品使用后，可以有效果&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">generic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        List&lt;LOL&gt; genericList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        genericList.add(<span class="keyword">new</span> GHero(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        genericList.add(<span class="keyword">new</span> GHero(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        genericList.add(<span class="keyword">new</span> GHero(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        genericList.add(<span class="keyword">new</span> GItem(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        genericList.add(<span class="keyword">new</span> GItem(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">        String test = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// DOES NOT WORK!</span></span><br><span class="line">            <span class="comment">//genericList.add(test);</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Walk-through-a-list"><a href="#3-Walk-through-a-list" class="headerlink" title="3.Walk through a list"></a>3.Walk through a list</h4><ul><li>avanced for loop:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强型for循环</span></span><br><span class="line"><span class="keyword">for</span>(LOL l:genericList)&#123;</span><br><span class="line">    System.out.println(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>iterator:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器简洁版本</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator&lt;LOL&gt; iter = genericList.iterator();iter.hasNext();)&#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用while的iterator</span></span><br><span class="line">        Iterator&lt;Hero&gt; it= heros.iterator();</span><br><span class="line">        <span class="comment">//从最开始的位置判断&quot;下一个&quot;位置是否有数据</span></span><br><span class="line">        <span class="comment">//如果有就通过next取出来，并且把指针向下移动</span></span><br><span class="line">        <span class="comment">//直到&quot;下一个&quot;位置没有数据</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Hero h = it.next();</span><br><span class="line">            System.out.println(h);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://user-images.githubusercontent.com/17522733/68083728-8c74ed00-fe2c-11e9-861f-61aaa9da5187.png" alt="806"></p><h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><blockquote><p>首先初始化一个Hero集合，里面放100个Hero对象，名称分别是从<br>hero 0<br>hero 1<br>hero 2<br>…<br>hero 99.<br>通过遍历的手段，删除掉名字编号是8的倍数的对象</p></blockquote><h4 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE:"></a><strong><em>NOTE:</em></strong></h4><p>If we use <code>testHero.remove(temp);</code> while reading this List, there will be an <code>java.util.ConcurrentModificationException</code> Error:<br><a href="https://www.cnblogs.com/dolphin0520/p/3933551.html">https://www.cnblogs.com/dolphin0520/p/3933551.html</a></p><p>Method1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">        List&lt;Hero&gt; testHero = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">        <span class="comment">// 放5个Hero进入容器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">99</span>; i++) &#123;</span><br><span class="line">            testHero.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero name &quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Iterator&lt;Hero&gt; iterator = testHero.iterator();iterator.hasNext();)&#123;</span><br><span class="line">            Hero temp = iterator.next();</span><br><span class="line"><span class="comment">//            wrong</span></span><br><span class="line"><span class="comment">//            char index = temp.name.charAt(temp.name.length() - 1);</span></span><br><span class="line">            <span class="keyword">int</span> index = Integer.parseInt(temp.name.substring(<span class="number">10</span>));</span><br><span class="line">            <span class="keyword">if</span>(index%<span class="number">8</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//                testHero.remove(temp);//wrong</span></span><br><span class="line">                <span class="comment">// Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line">                <span class="comment">//at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1042)</span></span><br><span class="line">                <span class="comment">//at java.base/java.util.ArrayList$Itr.next(ArrayList.java:996)</span></span><br><span class="line">                <span class="comment">//at com.company.generic.main(generic.java:71)</span></span><br><span class="line"><span class="comment">//                https://www.cnblogs.com/dolphin0520/p/3933551.html</span></span><br><span class="line">                iterator.remove();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Iterator&lt;Hero&gt; iterator = testHero.iterator();iterator.hasNext();)&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Method2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        testHero.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">99</span>; i++) &#123;</span><br><span class="line">            testHero.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero name &quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(testHero);</span><br><span class="line">        List&lt;Hero&gt; deleteHero = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//use another List to store the objects needed to be deleted</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator&lt;Hero&gt; iterator = testHero.iterator();iterator.hasNext();)&#123;</span><br><span class="line">            Hero temp = iterator.next();</span><br><span class="line"><span class="comment">//            char index = temp.name.charAt(temp.name.length() - 1); //wrong</span></span><br><span class="line">            <span class="keyword">int</span> index = Integer.parseInt(temp.name.substring(<span class="number">10</span>));</span><br><span class="line">            <span class="keyword">if</span>(index%<span class="number">8</span>==<span class="number">0</span>&amp;&amp;index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                deleteHero.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        testHero.removeAll(deleteHero);</span><br><span class="line">        System.out.println(testHero);</span><br></pre></td></tr></table></figure><h4 id="Other-sets"><a href="#Other-sets" class="headerlink" title="Other sets"></a>Other sets</h4><p>To be continued…</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Set </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客Hexo</title>
      <link href="archives/b085374e.html"/>
      <url>archives/b085374e.html</url>
      
        <content type="html"><![CDATA[<h2 id="如何使用Hexo来搭建个人博客？"><a href="#如何使用Hexo来搭建个人博客？" class="headerlink" title="如何使用Hexo来搭建个人博客？"></a>如何使用Hexo来搭建个人博客？</h2><p>本文的操作环境基于Windows10系统，生成文件部署与GitHub上，使用阿里云的个人域名进行重定向。</p> <a id="more"></a><ol><li><p>安装node，npm，cnpm，hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---#安装Nodejs</span><br><span class="line">node -v#查看node版本</span><br><span class="line">npm -v#查看npm版本</span><br><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org#安装淘宝的cnpm 管理器</span><br><span class="line">cnpm -v#查看cnpm版本</span><br><span class="line">cnpm install -g hexo-cli    #安装hexo框架</span><br><span class="line">hexo -v#查看hexo版本</span><br></pre></td></tr></table></figure></li><li><p>创建文件夹blog，进入该文件夹，初始化hexo，启动本地博客服务，尝试访问本地地址来查看效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir blog<span class="comment">#创建blog目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> blog <span class="comment">#进入blog目录</span></span></span><br><span class="line">hexo init #生成博客 初始化博客</span><br><span class="line">hexo s#启动本地博客服务</span><br><span class="line">http://localhost:4000/#本地访问地址</span><br></pre></td></tr></table></figure></li><li><p>新建文章，修改内容。<br>清理旧记录，创建新记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的第一篇文章&quot; #创建新的文章 </span><br><span class="line"><span class="meta">#</span><span class="bash">返回blog目录</span></span><br><span class="line">hexo clean #清理</span><br><span class="line">hexo g #生成</span><br></pre></td></tr></table></figure></li><li><p>在GitHub上创建一个新的仓库<code>YourGithubName.github.io</code>。【注意】需要保持第一个前缀与用户名完全一致，这是GitHubPages的要求。<br>使用cnpm安装git部署插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Github创建一个新的仓库 YourGithubName.github.io</span></span><br><span class="line">cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件</span><br></pre></td></tr></table></figure></li><li><p>在Hexo的配置文件<code>_config.yml</code>中添加GitHub的相关配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Deployment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></li><li><p>将本地仓库部署到GitHub上，访问对应的GitHubPages</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo d#部署到Github仓库里</span><br><span class="line">https://YourGithubName.github.io/  #访问这个地址可以查看博客</span><br></pre></td></tr></table></figure></li><li><p>下载合适的Hexo主题，修改Hexo配置文件以调整主题，访问对应的GitHubPages</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia  #下载yilia主题到本地</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">修改hexo根目录下的 _config.yml 文件 ： theme: yilia</span></span><br><span class="line">hexo c#清理一下</span><br><span class="line">hexo g#生成</span><br><span class="line">hexo d#部署到远程Github仓库</span><br><span class="line">https://YourGithubName.github.io/  #查看博客</span><br></pre></td></tr></table></figure></li><li><p>个性化域名：</p><p>GitHubPages可以接受www, blog, @这三种域名前缀。</p><ol><li><p>修改阿里云域名解析设置（推荐使用非顶级域名，即这里的主机记录设置为非@）：</p><table><thead><tr><th>主机记录</th><th>记录类型</th><th>解析线路</th><th>记录值</th></tr></thead><tbody><tr><td>blog</td><td>CNAME</td><td>默认</td><td>YourGithubName.github.io</td></tr></tbody></table></li><li><p>在本地目录中的source目录下，新建不带后缀的CNAME文件，在里面添加自己的域名，如<a href="https://blog.yulin.cool/">blog.yulin.cool</a>，即本站。然后hexo c; hexo g; hexo d; 将本地的变化推送到GitHub仓库上。</p></li><li><p>在GitHub上进行设置：点击repo中的Settings设置，找到Custom domain，填上自己的域名，比如<a href="https://blog.yulin.cool/">blog.yulin.cool</a>。</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
